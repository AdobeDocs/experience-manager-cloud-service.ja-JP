---
title: コンテンツフラグメントモデル
description: コンテンツフラグメントモデルが AEM のコンテンツフラグメントの基盤となる仕組みについて説明します。これらのフラグメントを使用すると、ヘッドレス配信やページオーサリングで使用する構造化コンテンツを作成できます。
feature: Content Fragments
role: User, Developer, Architect
exl-id: 8ab5b15f-cefc-45bf-a388-928e8cc8c603
source-git-commit: 6bb7b2d056d501d83cf227adb239f7f40f87d0ce
workflow-type: tm+mt
source-wordcount: '3058'
ht-degree: 59%

---

# コンテンツフラグメントモデル {#content-fragment-models}

Adobe Experience Manager(AEM) のコンテンツフラグメントモデルas a Cloud Serviceでは、 [コンテンツフラグメント](/help/sites-cloud/administering/content-fragments/overview.md). その後、これらのフラグメントは、ページオーサリングに使用したり、ヘッドレスコンテンツの基盤として使用したりできます。

コンテンツフラグメントモデルを使用するには、以下を行います。

1. [インスタンスに対するコンテンツフラグメントモデル機能の有効化](/help/sites-cloud/administering/content-fragments/setup.md)
1. コンテンツフラグメントモデルの[作成](#creating-a-content-fragment-model)と[設定](#defining-your-content-fragment-model)
1. コンテンツフラグメントの作成時に使用するために、[コンテンツフラグメントモデルを有効にする](#enabling-disabling-a-content-fragment-model)
1. **ポリシー**&#x200B;の設定による[必要なアセットフォルダーに対するコンテンツフラグメントモデルの許可](#allowing-content-fragment-models-assets-folder)

## コンテンツフラグメントモデルの作成 {#creating-a-content-fragment-model}

1. **ツール**／**一般**&#x200B;に移動し、**コンテンツフラグメントモデル**&#x200B;を開きます。
1. 次に該当するフォルダーに移動します。 [設定またはサブ設定](/help/sites-cloud/administering/content-fragments/setup.md).
1. 「**作成**」を使用してウィザードを開きます。

   >[!CAUTION]
   >
   >次の場合、 [コンテンツフラグメントモデルの使用が有効になっていません](/help/sites-cloud/administering/content-fragments/setup.md)、 **作成** オプションは使用できません。

1. 「**モデルタイトル**」を指定します。また、様々なプロパティ ( 例えば、 **タグ**, a **説明**&#x200B;を選択します。 **モデルを有効にする** から [モデルを有効にする](#enabling-disabling-a-content-fragment-model) 必要に応じて、
   **デフォルトのプレビュー URL パターン**.

   >[!NOTE]
   >
   >詳しくは、 [コンテンツフラグメントモデル — プロパティ](#content-fragment-model-properties) を参照してください。

   ![タイトルと説明](assets/cf-cfmodels-create.png)

1. 「**作成**」を使用して、空のモデルを保存します。アクションの成功を示すメッセージが表示されます。このメッセージで、「 **開く** をクリックして、モデルを直ちに編集するか、 **完了** コンソールに戻ります。

### コンテンツフラグメントモデル - プロパティ {#content-fragment-model-properties}

これらのプロパティは、モデルの作成時に定義され、後で **プロパティ** コンテンツフラグメントモデルのオプション：

* **基本**
   * **モデルタイトル**
   * **タグ**
   * **説明**
   * **モデルを有効化**
   * **デフォルトのプレビュー URL パターン**
コンテンツフラグメントエディターを使用すると、作成者は次の操作を実行できます。 **プレビュー** 外部フロントエンドアプリケーションのコンテンツ。 1 回 **プレビューサービス** が設定されている場合は、フロントエンドアプリケーションの URL を追加します。

     プレビュー URL は次のパターンに従う必要があります。
    `https://<preview_url>?param=${expression}`

     使用できる式は次のとおりです。

      * `${contentFragment.path}`
      * `${contentFragment.model.path}`
      * `${contentFragment.model.name}`
      * `${contentFragment.variation}`
      * `${contentFragment.id}`

   * **画像をアップロード**

<!-- CHECK: currently under FT -->
<!--
* **GraphQL**
  Define names relevant for GraphQL.
  Changing the GraphQL API Name, or Query field names will impact client applications.
  * **API Name**
    Represents the GraphQL type and query field names in the GraphQL schema.
  * **Single Query Field Name**
    Represents the GraphQL single query field name in the GraphQL schema.
  * **Multiple Query Field Name**
    Represents the GraphQL multiple query field name in the GraphQL schema.
-->

## コンテンツフラグメントモデルの定義 {#defining-your-content-fragment-model}

コンテンツフラグメントモデルは、選択した **[データタイプ](#data-types)**. モデルエディターを使用して、データ型のインスタンスを追加し、それらを設定して必須フィールドを作成できます。

>[!CAUTION]
>
>既存のコンテンツフラグメントで既に使用されているモデルを編集すると、それらの依存フラグメントに影響を与える可能性があります。

1. **ツール**／**一般**&#x200B;に移動し、**コンテンツフラグメントモデル**&#x200B;を開きます。

1. コンテンツフラグメントモデルを含むフォルダーに移動します。
1. 必要なモデルを **編集** 用に開きます。クイック操作を使用するか、モデルを選択してツールバーから操作を選択します。

   モデルエディターを開くと、次の内容が表示されます。

   * 左：フィールドが既に定義されています
   * 右：フィールドの作成に使用できる&#x200B;**データタイプ**（およびフィールドの作成後に使用する&#x200B;**プロパティ**）

   >[!NOTE]
   >
   >フィールドが **必須**、 **ラベル** 左側のウィンドウにアスタリスク (**&#42;**) をクリックします。

![プロパティ](assets/cf-cfmodels-empty-model.png)

1. **フィールドを追加するには**

   * 必要なデータタイプをフィールドの必要な場所にドラッグします。

     ![データタイプをドラッグしてフィールドを作成](assets/cf-cfmodels-create-field.png)

   * フィールドがモデルに追加されると、右側のパネルに **プロパティ** 特定のデータ型に対して定義できる ここで、そのフィールドに必要な項目を定義することができます。

      * 多くのプロパティは自明です。詳しくは「[プロパティ](#properties)」を参照してください。
      * a の入力 **フィールドラベル** 自動完了 **プロパティ名**   — 空の場合は、後で手動で更新できます。

        >[!CAUTION]
        >
        >プロパティを手動で更新する場合 **プロパティ名** データ型の場合、名前には次の文字が含まれている必要があります。 *のみ* A-Z、a-z、0-9、アンダースコア「_」は特殊文字として使用します。
        >
        >以前のバージョンの AEM で作成されたモデルに不正な文字が含まれている場合は、それらの文字を削除または更新します。

     次に例を示します。

     ![フィールドのプロパティ](assets/cf-cfmodels-field-properties.png)

1. **フィールドを削除するには**

   必須フィールドを選択し、ごみ箱アイコンを選択します。 このアクションの確認が求められます。

   ![削除](assets/cf-cfmodels-remove-icon.png)

1. すべての必須フィールドを追加し、必要に応じて関連するプロパティを定義します。次に例を示します。

   ![保存](assets/cf-cfmodels-save.png)します

1. 「**保存**」を選択して、定義を保持します。

## データタイプ {#data-types}

モデルの定義には、次のデータタイプを選択できます。

* **1 行のテキスト**
   * 1 行のテキストのフィールドを 1 つ以上追加（最大長は定義可能）
* **複数行テキスト**
   * リッチテキスト、プレーンテキストまたは Markdown のテキスト領域

  >[!NOTE]
  >
  >テキスト領域がリッチテキスト、プレーンテキスト、Markdown のどれであるかは、モデル内で、プロパティによって定義されます。 **デフォルトのタイプ**.
  >
  >この形式は、 [コンテンツフラグメントエディター](/help/sites-cloud/administering/content-fragments/authoring.md)モデルからのみ取得できます。

* **数値**
   * 1 つ以上の数値フィールドを追加
* **ブール型**
   * ブール型チェックボックスを追加
* **日時**
   * 日付や時刻を追加
* **列挙**
   * チェックボックス、ラジオボタン、ドロップダウンリストの各フィールドを追加する
* **タグ**
   * フラグメント作成者がタグの領域にアクセスして選択できるようにする
* **コンテンツ参照**
   * 任意の種類の他のコンテンツを参照し、[ネストされたコンテンツの作成](#using-references-to-form-nested-content)に使用可能
   * 画像が参照されている場合は、サムネールを表示するように選択可能
* **フラグメント参照**
   * 他のコンテンツフラグメントを参照します。 [ネストされたコンテンツを作成](#using-references-to-form-nested-content)
   * このデータタイプは、フラグメント作成者が次の操作を行えるように設定可能です。
      * 参照先フラグメントの直接編集
      * 適切なモデルに基づいて、新しいコンテンツフラグメントを作成します
* **JSON オブジェクト**
   * コンテンツフラグメント作成者がフラグメントの対応する要素に JSON 構文を入力できるようにします。
      * 別のサービスからコピー＆ペーストした JSON を AEM に直接保存できるようにする。
      * JSON が渡され GraphQL で JSON として出力されます。
      * JSON 構文のハイライト表示、オートコンプリート、エラーハイライト表示をコンテンツフラグメントエディターに組み込みます。
* **タブプレースホルダー**
   * コンテンツフラグメントコンテンツの編集時に使用するタブを導入可能
      * これらは、モデルエディターで区切りとして表示され、コンテンツデータタイプのリストの各セクションに分けられます。 各インスタンスは、新しいタブの開始を表します。

      * フラグメントエディターでは、各インスタンスがタブとして表示されます。

     >[!NOTE]
     >
     >このデータタイプは書式設定にのみ使用され、AEM GraphQL スキーマでは無視されます。

## プロパティ {#properties}

多くのプロパティは自明です。プロパティによっては次に示す追加の詳細情報があります。

* **プロパティ名**

  データ型のこのプロパティを手動で更新する場合、名前 **必須** 次を含む *のみ* A-Z、a-z、0-9、アンダースコア「_」は特殊文字として使用します。

  >[!CAUTION]
  >
  >以前のバージョンの AEM で作成されたモデルに不正な文字が含まれている場合は、それらの文字を削除または更新します。

* **レンダリング時の名前** フラグメント内のフィールドを実現／レンダリングするための様々なオプション。多くの場合、作成者がフィールドの 1 つのインスタンスを表示するか、複数のインスタンスを作成できるかを定義できます。

* **フィールドラベル**
の入力 **フィールドラベル** を自動生成します。 **プロパティ名**（必要に応じて手動で更新できます）

* **検証**基本検証は、
**必須**&#x200B;プロパティなどのメカニズムで使用できます。一部のデータ型には、追加の検証フィールドがあります。詳しくは、「[検証](#validation)」を参照してください。

* データタイプが&#x200B;**複数行テキスト**&#x200B;の場合、「**デフォルトの種類**」を次のいずれかとして定義できます。

   * **リッチテキスト**
   * **Markdown**
   * **プレーンテキスト**

  指定しなかった場合は、デフォルト値の&#x200B;**リッチテキスト**&#x200B;がこのフィールドで使用されます。

  の変更 **デフォルトのタイプ** コンテンツフラグメントモデルで有効になるのは、そのフラグメントがエディターで開かれて保存された後で、関連する既存のコンテンツフラグメントに対してのみです。

* **ユニーク**
（特定のフィールドの）コンテンツは、現在のモデルから作成されるすべてのコンテンツフラグメントで一意である必要があります。

  これにより、同じモデルの別のフラグメントに既に追加されているコンテンツをコンテンツ作成者が繰り返し作成できないようになります。

  例えば、コンテンツフラグメントモデルの **1 行のテキスト**&#x200B;フィールド `Country` は、2 つの依存するコンテンツフラグメントで同じ `Japan` 値を持つことはできません。2 つ目のインスタンスが試行された場合、警告が表示されます。

  >[!NOTE]
  >
  >言語ルートごとに一意性が確保されます。

  >[!NOTE]
  >
  >バリエーションは、同じフラグメントのバリエーションと同じ&#x200B;*一意の*&#x200B;値を持つことができますが、他のフラグメントのバリエーションで使用されている値とは異なります。

* 特定のデータタイプとそのプロパティについて詳しくは、**[コンテンツ参照](#content-reference)**&#x200B;を参照してください。

* 特定のデータタイプとそのプロパティについて詳しくは、**[フラグメント参照（ネストされたフラグメント）](#fragment-reference-nested-fragments)**&#x200B;を参照してください。

* **変換可能**

  コンテンツフラグメントモデルエディターのフィールドの「**翻訳可能**」チェックボックスをオンにした場合：

   * フィールドのプロパティ名がまだ存在しない場合は、翻訳設定のコンテキスト `/content/dam/<sites-configuration>` に確実に追加されます。
   * GraphQL の場合：「コンテンツフラグメント」フィールドの `<translatable>` プロパティを `yes` に設定して、変換可能なコンテンツのみを含む JSON を出力するための GraphQL クエリフィルターを許可します。

## 検証 {#validation}

様々なデータ型に、結果のフラグメントにコンテンツが入力される際の検証要件を定義できるようになりました。

* **1 行のテキスト**
   * 事前定義された正規表現と比較します。
* **数値**
   * 特定の値を確認します。
* **コンテンツ参照**
   * 特定のタイプのコンテンツをテストします。
   * 指定したファイルサイズ以下のアセットのみを参照できます。
   * 定義済みの幅または高さ（ピクセル単位）の範囲に収まる画像のみを参照できます。
* **フラグメント参照**
   * 特定のコンテンツフラグメントモデルをテストします。

## 参照の使用によるネストされたコンテンツの作成 {#using-references-to-form-nested-content}

コンテンツフラグメントは、次のいずれかのデータタイプを使用して、ネストされたコンテンツを作成できます。

* **[コンテンツ参照](#content-reference)**
   * 他のコンテンツへの単純な参照（任意のタイプ）を提供します。
   * （結果のフラグメント内で）1 つまたは複数の参照に対して設定できます。

* **[フラグメント参照](#fragment-reference-nested-fragments)**（ネストされたフラグメント）
   * 指定した特定のモデルに応じて、他のフラグメントを参照します。
   * 構造化データを包含／取得できます。

     >[!NOTE]
     >
     >この方法は、 [GraphQLでコンテンツフラグメントを使用したヘッドレスコンテンツ配信](/help/sites-cloud/administering/content-fragments/content-delivery-with-graphql.md).
   * （結果のフラグメントで）1 つ以上の参照に対して設定できます。

>[!NOTE]
>
>AEMは次の繰り返し保護を持ちます：
>
>* コンテンツ参照
>  これにより、ユーザーは現在のフラグメントに参照を追加できなくなり、フラグメント参照ピッカーダイアログが空になる場合があります。
>
>* GraphQL のフラグメント参照
>  相互に参照される複数のコンテンツフラグメントを返すディープクエリを作成した場合、1 番目の値では null が返されます。

### コンテンツ参照 {#content-reference}

コンテンツ参照を使用すると、画像、ページ、エクスペリエンスフラグメントなど、別のソースからコンテンツをレンダリングできます。

標準プロパティに加えて、次のものを指定できます。

* The **ルートパス**：参照コンテンツを保存する場所を指定します。
  >[!NOTE]
  >
  >これは、コンテンツフラグメントエディターの使用時に、このフィールドで画像を直接アップロードして参照する場合に必須です。
  >
  >詳しくは、 [参照画像](/help/sites-cloud/administering/content-fragments/authoring.md#reference-images) 詳しくは、を参照してください。

* 参照可能なコンテンツタイプ
  >[!NOTE]
  >
  >次を含める必要があります。 **画像** コンテンツフラグメントエディターの使用時に、このフィールドで画像を直接アップロードして参照する場合。
  >
  >詳しくは、 [参照画像](/help/sites-cloud/administering/content-fragments/authoring.md#reference-images) 詳しくは、を参照してください。

* ファイルサイズの制限
* 画像が参照されている場合：
   * サムネールを表示
   * 画像の高さと幅の制限

![コンテンツ参照](assets/cf-cfmodels-content-reference.png)

### フラグメント参照（ネストされたフラグメント） {#fragment-reference-nested-fragments}

フラグメント参照は、1 つ以上のコンテンツフラグメントを参照します。 この機能は、複数のレイヤーを持つ構造化データを取得できるので、アプリで使用するコンテンツを取得する場合に特に重要です。

次に例を示します。

* 従業員の詳細を定義するモデル。次のものが含まれます。
   * 事業主（会社）を定義するモデルへの参照

```xml
type EmployeeModel {
    name: String
    firstName: String
    company: CompanyModel
}

type CompanyModel {
    name: String
    street: String
    city: String
}
```

>[!NOTE]
>
>フラグメント参照は、 [GraphQLでコンテンツフラグメントを使用したヘッドレスコンテンツ配信](/help/sites-cloud/administering/content-fragments/content-delivery-with-graphql.md).

標準プロパティに加えて、次のものを定義できます。

* **レンダリング時の名前**:

   * **multifield** - フラグメント作成者は個別の参照を複数作成できます。

   * **fragmentreference** - フラグメント作成者はフラグメントへの 1 つの参照を選択できます。

* **モデルタイプ**：
複数のモデルを選択できます。コンテンツフラグメントに参照を追加する場合、参照されるフラグメントは、これらのモデルを使用して作成されている必要があります。

* **ルートパス**：
任意の参照先フラグメントのルートパスを指定します。

* **フラグメントの作成を許可**

  これにより、フラグメント作成者は、適切なモデルに基づいてフラグメントを作成できます。

   * **fragmentreferencecomposite** - フラグメント作成者が複数のフラグメントを選択して複合フラグメントを作成できるようになります。

  ![フラグメント参照](assets/cf-cfmodels-fragment-reference.png)

>[!NOTE]
>
>繰り返し防止メカニズムが設定されます。これにより、ユーザーがフラグメント参照で現在のコンテンツフラグメントを選択することが禁止され、フラグメント参照ピッカーダイアログが空になる場合があります。
>
>また、GraphQLのフラグメント参照に対する繰り返し保護もあります。 相互に参照する 2 つのコンテンツフラグメントにまたがるディープクエリを作成すると、null が返されます。

## コンテンツフラグメントモデルの有効化または無効化 {#enabling-disabling-a-content-fragment-model}

次のいずれかを実行できます。 **有効にする** または **無効にする** コンテンツフラグメントモデルを使用して、その使用を完全に制御できます。

### コンテンツフラグメントモデルの有効化 {#enabling-a-content-fragment-model}

モデルを作成したら、次の操作を実行するために有効にする必要があります。

* コンテンツフラグメントの作成時に選択できます。
* コンテンツフラグメントモデル内から参照する
* GraphQL で使用する（スキーマが生成される）

次のいずれかとしてフラグ付けされたモデルを有効にするには

* **ドラフト** ：新規（無効）
* **無効**：明示的に無効化されている

**「**&#x200B;有効化」オプションは、次のいずれかから使用します。

* 上部のツールバー（必要なモデルが選択されている場合）
* 対応するクイックアクション（必要なモデルにマウスを移動）

![ドラフトまたは無効なモデルの有効化](assets/cf-cfmodels-status-enable.png)

### コンテンツフラグメントモデルの無効化 {#disabling-a-content-fragment-model}

モデルを無効にすると、以下のようになります。

* このモデルは、*新しい*&#x200B;コンテンツフラグメントを作成する際の基盤としては使用できなくなります。
* ただし、
   * GraphQL スキーマは生成され続け、スキーマのクエリも引き続き可能です（JSON API への影響を回避するため）。
   * モデルに基づくコンテンツフラグメントは、引き続き GraphQL エンドポイントからクエリして返すことができます。
* モデルは参照できなくなりますが、既存の参照は変更されず、引き続き GraphQL エンドポイントからクエリして返すことができます。

次のフラグが設定されたモデルを無効にするには **有効**&#x200B;を使用する場合、 **無効にする** 次のいずれかのオプション：

* 上部のツールバー（必要なモデルが選択されている場合）
* 対応するクイックアクション（必要なモデルにマウスを移動）

![有効なモデルの無効化](assets/cf-cfmodels-status-disable.png)

## アセットフォルダーでのコンテンツフラグメントモデルの許可 {#allowing-content-fragment-models-assets-folder}

コンテンツのガバナンスを実装するには、アセットフォルダーに&#x200B;**ポリシー**&#x200B;を設定して、そのフォルダーでのフラグメント作成に使用可能なコンテンツフラグメントモデルを管理します。

>[!NOTE]
>
>このメカニズムは、ページの高度なプロパティでページとその子に対して[ページテンプレートを許可する](/help/sites-cloud/authoring/features/templates.md#allowing-a-template-author)ことに似ています。

**許可されているコンテンツフラグメントモデル**&#x200B;に&#x200B;**ポリシー**&#x200B;を設定するには：

1. 必要なアセットフォルダーの&#x200B;**プロパティ**&#x200B;を開きます。

1. 「**ポリシー**」タブを開き、以下を設定します。

   * **継承元`<folder>`**

     新しい子フォルダーを作成すると、ポリシーは自動的に継承されます。親フォルダーとは異なるモデルをサブフォルダーに許可する必要がある場合は、ポリシーを再設定（および継承を解除）できます。

   * **許可されているコンテンツフラグメントモデルパス (パス別)**

     複数のモデルを許可できます。

   * **許可されているコンテンツフラグメントモデルタグ (タグ別)**

     複数のモデルを許可できます。

   ![コンテンツフラグメントモデルポリシー](assets/cf-cfmodels-policy-assets-folder.png)

1. 変更内容を&#x200B;**保存**&#x200B;します。

フォルダーに対して許可されるコンテンツフラグメントモデルは、次の順序で解決されます。
* **許可されているコンテンツフラグメントモデル**&#x200B;の&#x200B;**ポリシー**。
* 空の場合は、継承ルールを使用してポリシーの決定を試みます。
* 継承チェーンを使用しても結果が得られない場合は、そのフォルダーの **Cloud Services** 設定を調べます（最初は直接、次に継承を使用して調べます）。
* 上記のいずれでも結果が得られない場合、そのフォルダーに許可されるモデルはありません。

## コンテンツフラグメントモデルの削除 {#deleting-a-content-fragment-model}

>[!CAUTION]
>
>コンテンツフラグメントモデルを削除すると、依存するフラグメントに影響を与える場合があります。

コンテンツフラグメントモデルを削除するには：

1. **ツール**／**一般**&#x200B;に移動し、**コンテンツフラグメントモデル**&#x200B;を開きます。

1. コンテンツフラグメントモデルを含むフォルダーに移動します。
1. モデルを選択し、次にツールバーの「**削除**」を選択します。

   >[!NOTE]
   >
   >モデルが参照されている場合は、適切なアクションを実行できるように警告が表示されます。

## コンテンツフラグメントモデルの公開 {#publishing-a-content-fragment-model}

依存するコンテンツフラグメントが公開される前または後に、コンテンツフラグメントモデルを公開する必要があります。

コンテンツフラグメントモデルを公開するには：

1. **ツール**／**一般**&#x200B;に移動し、**コンテンツフラグメントモデル**&#x200B;を開きます。

1. コンテンツフラグメントモデルを含むフォルダーに移動します。
1. モデルを選択し、次にツールバーの「**公開**」を選択します。公開済みのステータスがコンソールに表示されます。

   >[!NOTE]
   >
   >モデルがまだ公開されていないコンテンツフラグメントを公開する場合、選択リストにその旨が表示され、モデルはフラグメントと共に公開されます。

## コンテンツフラグメントモデルを非公開にする {#unpublishing-a-content-fragment-model}

コンテンツフラグメントモデルがどのフラグメントでも参照されていない場合は、非公開にできます。

コンテンツフラグメントモデルを非公開にするには：

1. **ツール**／**一般**&#x200B;に移動し、**コンテンツフラグメントモデル**&#x200B;を開きます。

1. コンテンツフラグメントモデルを含むフォルダーに移動します。
1. モデルを選択し、次にツールバーの「**非公開**」を選択します。公開ステータスがコンソールに示されます。

1 つ以上のフラグメントで現在使用されているモデルを非公開にしようとすると、エラー警告が表示されます。 次に例を示します。

![使用中のモデルを非公開にするときに表示されるコンテンツフラグメントモデルのエラーメッセージ](assets/cf-cfmodels-unpublish-error.png)

このメッセージでは、 [参照](/help/sites-cloud/authoring/getting-started/basic-handling.md#references) 詳細を調べるパネル：

![参照パネル内のコンテンツフラグメントモデル](assets/cf-cfmodels-references.png)

## ロック済み（公開済み）コンテンツフラグメントモデル {#locked-published-content-fragment-models}

この機能は、公開済みのコンテンツフラグメントモデルに対するガバナンスを提供します。

### 課題 {#the-challenge}

* コンテンツフラグメントモデルは、AEM における GraphQL クエリのスキーマを決定します。

   * AEM GraphQL スキーマは、コンテンツフラグメントモデルが作成されると同時に作成され、オーサー環境とパブリッシュ環境の両方に存在できます。

   * 公開上のスキーマは、JSON 形式のコンテンツフラグメントコンテンツをライブ配信する場合の基盤となるので、非常に重要です。

* コンテンツフラグメントモデルが変更つまり編集された場合には、問題が発生する可能性があります。つまり、スキーマの変更が既存の GraphQL クエリに影響を与える可能性があります。

* コンテンツフラグメントモデルに新しいフィールドを追加する場合は、（通常は）悪影響はありません。ただし、既存のデータフィールド（名前など）を変更したり、フィールド定義を削除したりすると、既存の GraphQL クエリでこれらのフィールドをリクエストする際に、クエリが機能しなくなります。

### 要件 {#the-requirements}

* ライブコンテンツ配信に既に使用されているモデル（つまり、公開済みのモデル）を編集する際のリスクをユーザーに認識させる。

* 意図しない変更を避ける。

変更されたモデルが再公開されると、どちらの条件でもクエリが壊れる場合があります。

### 解決策 {#the-solution}

これらの問題に対処するために、コンテンツフラグメントモデルは、公開され次第、オーサー環境では読み取り専用モードに&#x200B;*ロック*&#x200B;されます。このステータスは、 **ロック済み**:

![ロックされたコンテンツフラグメントモデルのカード](assets/cf-cfmodels-locked.png)

モデルが&#x200B;**ロック済み**（読み取り専用モード）の場合、モデルの内容と構造は表示できますが、モデルを編集することはできません。

**ロック済み**&#x200B;モデルは、コンソールまたはモデルエディターで管理できます。

* コンソール

  コンソールで、ツールバーの「**ロック解除**」および「**ロック**」アクションを使用して、読み取り専用モードを管理できます。

  ![ロックされたコンテンツフラグメントモデルのツールバー](assets/cf-cfmodels-locked.png)

   * モデルを&#x200B;**ロック解除**&#x200B;して編集を有効にすることができます。

     次を選択した場合、 **ロック解除** 警告が表示され、確認する必要があります。 **ロック解除** アクション：
     ![コンテンツフラグメントモデルをロック解除する際のメッセージ](assets/cf-cfmodels-unlock-message.png)

     その後、モデルを編集用に開くことができます。

   * 編集後にまたモデルを&#x200B;**ロック**&#x200B;することもできます。
   * モデルを再公開すると、すぐにに戻ります。 **ロック済み** （読み取り専用）モード。

* モデルエディター

   * ロックされているモデルを開くと、警告が表示され、「**キャンセル**」、「**読み取り専用で表示**」、「**編集**」の 3 つのアクションが提示されます。

     ![ロックされたコンテンツフラグメントモデルを表示する際のメッセージ](assets/cf-cfmodels-editor-lock-message.png)

   * 次を選択した場合、 **読み取り専用を表示**&#x200B;を使用すると、モデルのコンテンツと構造を確認できます。

     ![読み取り専用で表示 - ロックされたコンテンツフラグメントモデル](assets/cf-cfmodels-editor-locked-view-only.png)

   * 次を選択した場合、 **編集**、以下の方法で更新内容を編集および保存できます。

     ![編集 - ロックされたコンテンツフラグメントモデル](assets/cf-cfmodels-editor-locked-edit.png)

     >[!NOTE]
     >
     >まだ上部に警告が表示される場合がありますが、その場合は、モデルが既存のコンテンツフラグメントで既に使用されています。

   * **キャンセル** コンソールに戻ります。
