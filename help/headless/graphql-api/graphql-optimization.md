---
title: GraphQLクエリの最適化
description: ヘッドレスコンテンツ配信のためにAdobe Experience Manager as a Cloud Serviceでコンテンツフラグメントをフィルタリング、ページング、並べ替える際に、GraphQLクエリを最適化する方法について説明します。
source-git-commit: 0fe0bd301fb09cdc631878926f2e40df51a2cc23
workflow-type: tm+mt
source-wordcount: '1192'
ht-degree: 0%

---


# GraphQLクエリの最適化 {#optimizing-graphql-queries}

>[!NOTE]
>
>これらの最適化レコメンデーションを適用する前に、以下を検討してください。 [GraphQLフィルタリングでのページングと並べ替えのためのコンテンツフラグメントの更新](/help/headless/graphql-api/graphql-optimized-filtering-content-update.md) 最高のパフォーマンスを実現するには

同じモデルを共有するコンテンツフラグメントが多数あるAEMインスタンスでは、GraphQLのリストクエリに（リソースの点で）コストがかかる場合があります。

これは、 *すべて* GraphQLクエリ内で使用されているモデルを共有するフラグメントは、メモリに読み込む必要があります。 これは時間とメモリの両方を消費します。 （最終的な）結果セット内の項目数を減らす可能性のあるフィルタリングは、のみ適用できます **後** 結果セット全体をメモリに読み込む。

これにより、小さな結果セットでもパフォーマンスが低下する可能性があるというインプレッションが発生する場合があります。 ただし、実際には、フィルタリングを適用する前に内部で処理する必要があるので、遅延は初期結果セットのサイズに起因します。

パフォーマンスとメモリの問題を減らすには、この初期結果セットをできるだけ小さく保つ必要があります。

AEMには、GraphQLクエリを最適化する 2 つの方法があります。

* [ハイブリッドフィルター](#hybrid-filtering)
* [ページング](#paging) （またはページネーション）

   * [並べ替え](#sorting) は、最適化に直接関連していませんが、ページングに関連しています

各アプローチには、独自の使用例と制限があります。 このドキュメントでは、ハイブリッドフィルターとページングに関する情報と、 [ベストプラクティス](#best-practices) GraphQLクエリを最適化する

## ハイブリッドフィルター {#hybrid-filtering}

ハイブリッドフィルタリングは、JCR フィルタリングとAEMフィルタリングを組み合わせます。

AEMフィルタリング用のメモリに結果セットを読み込む前に、（クエリ制約の形式で）JCR フィルターを適用します。 これは、JCR フィルターによって余分な結果が削除されるので、メモリに読み込まれる結果セットを減らすためです。

>[!NOTE]
>
>技術的な理由（柔軟性、フラグメントのネストなど）により、AEMはフィルター全体を JCR に委任できません。

この方法では、GraphQLフィルターが提供する柔軟性を維持しながら、可能な限り多くのフィルターを JCR に委任できます。

## ページング {#paging}

AEMのGraphQLでは、次の 2 種類のページネーションをサポートしています。

* [制限/オフセットベースのページネーション](/help/headless/graphql-api/content-fragments.md#list-offset-limit)
これは、リストクエリに使用されます。これらは次の値で終わる 
`List`;例： `articleList`.
これを使用するには、最初に返す項目 ( `offset`) と返す項目の数 ( `limit`またはページサイズ )。

* [カーソルベースのページネーション](/help/headless/graphql-api/content-fragments.md#paginated-first-after) ( 次で表される： `first`および `after`) 項目ごとに一意の ID を提供します。「カーソル」とも呼ばれます。
クエリでは、前のページの最後の項目のカーソルと、ページサイズ（返される項目の最大数）を指定します。

   カーソルベースのページネーションはリストベースのクエリのデータ構造内に収まらないので、AEMでは `Paginated` クエリのタイプ；例： `articlePaginated`. 使用されるデータ構造とパラメーターは、 [GraphQL Cursor ConnectionSpecification](https://relay.dev/graphql/connections.htm).

   >[!NOTE]
   >
   >AEMは現在、フォワードページングをサポートしています ( `after`/`first` パラメータ )。
   >
   >後方ページ（を使用） `before`/`last` パラメーター ) はサポートされていません。

## 並べ替え {#sorting}

並べ替えは、すべての並べ替え条件が最上位のフラグメントに関連している場合にのみ効率的です。

並べ替え順に、ネストされたフラグメントに配置された 1 つ以上のフィールドが含まれる場合は、最上位モデルを共有するすべてのフラグメントをメモリに読み込む必要があります。 これにより、パフォーマンスに悪影響が出ます。

>[!NOTE]
>
>トップレベルのフィールドでの並べ替えも、（小さくても）パフォーマンスに影響を与えます。

## ベストプラクティス {#best-practices}

すべての最適化の主な目的は、初期結果セットを減らすことです。 ここに示すベストプラクティスには、その方法が記載されています。 組み合わせ可能（および必要）です。

### トップレベルのプロパティのみをフィルター {#filter-top-level-properties-only}

現在、JCR レベルでのフィルタリングは、トップレベルのフラグメントに対してのみ機能します。

フィルターがネストされたフラグメントのフィールドに対応する場合、AEMは、基になるモデルを共有するすべてのフラグメントの読み込み（メモリへの読み込み）にフォールバックする必要があります。

その場合でも、トップレベルフラグメントのフィールドとネストされたフラグメントのフィールドのフィルター式を、 [AND 演算子](#logical-operations-in-filter-expressions).

### コンテンツ構造の使用 {#use-content-structure}

AEMでは、通常、リポジトリ構造を使用して、処理するコンテンツの範囲を絞り込むことをお勧めします。

この方法は、GraphQLクエリにも適用する必要があります。

これは、 `_path` 最上位フラグメントのフィールド：

```graphql
{
  someList(filter: {
    _path: {
      _expressions: [ 
        {
          value: "/content/dam/some/sub/path/",
          _operator: STARTS_WITH
        }
      ]
    }
  }) {
    items {
      # ...
    }
  }
}
```

>[!NOTE]
>
>末尾の `/` オン `value` が最高のパフォーマンスを達成するために必要です。

### ページングを使用 {#use-paging}

ページングを使用して、初期の結果セットを減らすこともできます。特に、リクエストでフィルタリングと並べ替えを使用しない場合には注意が必要です。

ネストされたフラグメントをフィルターまたは並べ替える場合でも、AEMは大量のフラグメントをメモリに読み込む必要があるので、ページ分割されたクエリの処理に時間がかかる場合があります。 したがって、フィルタリングとページングを組み合わせる場合は、（前述のように）フィルタリングのルールを考慮します。

ページングの場合、並べ替えは同様に重要です。ページ分割された結果は常に明示的または暗黙的に並べ替えられるからです。

最初の数ページのみを取得したい場合、 `...List` または `...Paginated` クエリ。 ただし、1～2 ページ以上のページを読みたい場合は、 `...Paginated` クエリを使用することをお勧めします。後のページでは、特にパフォーマンスが向上します。

### フィルター式の論理演算 {#logical-operations-in-filter-expressions}

ネストされたフラグメントをフィルタリングする場合、JCR フィルタリングを活用できます。そのため、 `AND` 演算子

一般的な使用例は、 `_path` 最上位フラグメントのフィールドを選択し、最上位レベルのフィールドまたはネストされたフラグメント上の追加のフィールドをフィルタリングします。

この場合、異なるフィルター式を `AND`. したがって、 `_path` では、初期の結果セットを効果的に制限できます。 トップレベルフィールドのその他すべてのフィルターは、と組み合わされている限り、初期結果セットの削減にも役立ちます `AND`.

と組み合わされたフィルター式 `OR` ネストされたフラグメントが関与している場合、最適化できません。 `OR` 式は、次の場合にのみ最適化できます： *いいえ* ネストされたフラグメントも含まれます。

### 複数行のテキストフィールドに対するフィルタリングを避ける {#avoid-filtering-multiline-textfields}

複数行のテキストフィールド (html、markdown、plaintext、json) のフィールドは、JCR クエリでフィルタリングできません。これらのフィールドの内容をオンザフライで計算する必要があるからです。

それでも複数行のテキストフィールドに対してフィルタを設定する必要がある場合は、フィルタ式を追加して、 `AND`. に対するフィルタリングによる範囲の制限 `_path` フィールドも適切なアプローチです。

### 仮想フィールドに対するフィルタリングを回避 {#avoid-filtering-virtual-fields}

仮想フィールド ( ほとんどのフィールドは `_`) はGraphQLクエリの実行中に計算されるので、JCR ベースのフィルタリングの範囲外です。

重要な例外は `_path` フィールド（最初の結果セットのサイズを小さくするために効果的に使用できます）。コンテンツが適切に構造化されている場合は ( [コンテンツ構造の使用](#use-content-structure)) をクリックします。

### フィルター：除外 {#filtering-exclusions}

JCR レベルでフィルター式を評価できない場合も、他にもいくつかあります（したがって、最高のパフォーマンスを得るには避ける必要があります）。

* の式のフィルタリング `Float` 値 `_sensitiveness` フィルターオプション、および `_sensitiveness` が次の値以外に設定されている場合は、 `0.0` .

* の式のフィルタリング `String` 値を `_ignoreCase` フィルターオプション。

* フィルター `null` 値。

* を使用した配列に対するフィルター `_apply: ALL_OR_EMPTY`.

* を使用した配列に対するフィルター `_apply: INSTANCES`, `_instances: 0`.

* を使用した式のフィルタリング `CONTAINS_NOT` 演算子

* の式のフィルタリング `Calendar`, `Date` または `Time` 値 `NOT_AT` 演算子
