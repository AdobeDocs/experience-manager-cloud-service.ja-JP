---
title: フロントエンドパイプラインを使用したサイトの開発
description: フロントエンドパイプラインを使用すると、フロントエンド開発者により多くの独立性が与えられ、開発プロセスは大幅な速度を得ることができます。
exl-id: 996fb39d-1bb1-4dda-a418-77cdf8b307c5
source-git-commit: 940a01cd3b9e4804bfab1a5970699271f624f087
workflow-type: tm+mt
source-wordcount: '1024'
ht-degree: 0%

---

# フロントエンドパイプラインを使用したサイトの開発 {#developing-site-with-front-end-pipeline}

[フロントエンドパイプラインを使用する場合、](/help/implementing/cloud-manager/configuring-pipelines/introduction-ci-cd-pipelines.md#front-end) フロントエンド開発者にはより独立性が与えられ、開発プロセスは大幅な速度を得ることができます。 このドキュメントでは、このプロセスの可能性を最大限に活かすために、このプロセスがどのように機能するかと、注意が必要な考慮事項について説明します。

>[!TIP]
>
>フロントエンドパイプラインの使用方法とメリットについてまだ詳しくない場合は、 [クイックサイト作成ジャーニー](/help/journey-sites/quick-site/overview.md) 新しいサイトをすばやくデプロイし、そのテーマをバックエンド開発とは完全に無関係にカスタマイズする方法の例を示します。

## 唯一の情報源 {#single-source-of-truth}

一般的なベストプラクティスは、AEMにデプロイされているものに対して、1 つの情報源を維持することです。 Cloud Manager の目的は、その一つの真実の源を明確にすることです。 ただし、フロントエンドパイプラインによってコードの一部の場所が分離できるので、追加の責任はフロントエンドパイプラインの正しい設定にあります。 同じ環境の同じサイトにデプロイする複数のフロントエンドパイプラインを作成しないように、注意が必要です。

このため、特に複数のフロントエンドパイプラインが作成される場合は、次のような体系的な命名規則を維持することをお勧めします。

* フロントエンドモジュールの名前。 `name` プロパティ `package.json` ファイルの中に、適用先のサイトの名前を含める必要があります。 例えば、次の場所にあるサイトの場合： `/content/wknd`フロントエンドモジュールの名前は次のようになります。 `wknd-theme`.
* フロントエンドモジュールが他のモジュールと同じ Git リポジトリを共有する場合、そのフォルダーの名前はフロントエンドモジュールと同じか、同じ名前を含む必要があります。 例えば、フロントエンドモジュールの名前が `wknd-theme`を含める場合、含まれるフォルダー名は次のようになります。 `wknd-theme-sources`.
* Cloud Manager フロントエンドパイプラインの名前には、フロントエンドモジュールの名前も含め、デプロイ先の環境（実稼動または開発）を追加する必要があります。 例えば、という名前のフロントエンドモジュールの場合、 `wknd-theme`に値を指定しない場合、パイプラインに次のような名前を付けることができます。 `wknd-theme-prod`.

このような規則により、次のデプロイメントエラーを効率的に防ぐ必要があります。

* フロントエンドモジュールを間違ったサイトに適用する
* 同じサイトを適用する複数のフロントエンドモジュールを作成すると、相互に上書きされます
* 同じソースに対して複数のフロントエンドパイプラインを作成すると、競合状態が発生する可能性があり、デプロイメントの順序は保証されない

## 関心の分離 {#separation-of-concerns}

懸念の分離に適用されるもう 1 つのベストプラクティスは、懸念を分離する契約の設計と管理の方法を特に注意することです。 フロントエンドパイプラインの場合、そのコードを他のコードと分離する契約は、サイトによってレンダリングされるHTMLと JSON です。 そのHTMLと JSON が安定したままの場合、フロントエンドパイプラインは、フロントエンドチームを完全に独立させることで、最大限の価値を提供します。

現在、フロントエンドパイプラインと同期してフルスタックパイプラインを実行する特定の機能はありません。 このため、フロントエンド開発をフルスタックパイプラインから分離する場合は、これら 2 つの懸念事項を区別する契約に細心の注意を払う必要があります。 この契約は、通常、Experience ManagerがレンダリングするHTMLや JSON です。 したがって、異なるパイプラインを操作するチーム間で、対応する変更のシーケンス化方法に同意するよう、その契約の変更を適切に計画する必要があります。

HTMLや JSON 出力の変更が両方の懸念事項に影響を与える場合は、通常、次の手順を実行することをお勧めします。

1. バックエンドチームは、まず、新しいHTML/JSON 出力を使用して開発環境を設定します。
   1. フルスタックパイプラインを介して、必要な新しいHTMLや JSON 出力のレンダリングに必要なコードをデプロイします。
   1. フロントエンドチームが以前にアクセス権を持っていなかった環境の場合は、次の手順を実行する必要があります。
      1. URL:フロントエンドチームは、その開発環境の URL を知っている必要があります。
      1. ACL:フロントエンドチームには、「寄稿者」権限と似た権限を持つローカルAEMユーザーが割り当てられている必要があります。
      1. Git:フロントエンドチームには、その開発環境を特別にターゲットにするフロントエンドモジュール用の Git の場所が別に存在する必要があります。
         * 通常は、 `dev` ブランチを使用して、開発環境でおこなった変更を簡単に再び `main` 実稼動環境にデプロイするブランチ。
      1. パイプライン：フロントエンドチームには、開発環境にデプロイされるフロントエンドパイプラインが必要です。 そのパイプラインは、通常、 `dev` 前のポイントで説明したように、ブランチに追加します。
1. 次に、フロントエンドチームは、CSS と JS コードを古い出力と新しい出力の両方で動作させます。
   1. 通常どおり、ローカルで開発するには、次の手順を実行します。
      1. この `npx aem-site-theme-builder proxy` フロントエンドモジュール内で実行されるコマンドは、フロントエンドモジュールの CSS および JS ファイルをローカルファイルに置き換えながら、AEM環境からコンテンツをリクエストするプロキシサーバーを開始します `dist` フォルダー。
      1. の設定 `AEM_URL` 非表示の変数 `.env` ファイルを使用すると、ローカルプロキシサーバーがコンテンツを消費するAEM環境を制御できます。
      1. この値の変更 `AEM_URL` したがって、では、実稼動環境と開発環境を切り替えて、両方の環境に適合するように CSS と JS を調整できます。
      1. 新しい出力をレンダリングする開発環境と、古い出力をレンダリングする実稼動環境で動作する必要があります。
   1. フロントエンドの作業は、更新されたフロントエンドモジュールが両方の環境で動作し、両方にデプロイされると完了します。
1. その後、バックエンドチームは、フルスタックパイプラインを介して新しいHTMLや JSON 出力をレンダリングするコードをデプロイすることで、実稼動環境を更新できます。
1. 次に、フロントエンドチームは、CSS と JS をクリーンアップし、古い出力でのみ必要だったものを削除し、フロントエンドパイプラインを介して最後の更新を実稼動環境にデプロイできます。

## その他のリソース {#additional-resources}

* [サイトテーマ](/help/sites-cloud/administering/site-creation/site-themes.md) - AEMサイトテーマを使用して、サイトのスタイルやデザインをカスタマイズする方法を説明します。
* [AEM Site Theme Builder](https://github.com/adobe/aem-site-theme-builder) -Adobeは、新しいサイトテーマを作成するための一連のスクリプトとしてAEM Site Theme Builder を提供します。
