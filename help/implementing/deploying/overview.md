---
title: クラウドサービスとしてのAEMへのデプロイ
description: 'クラウドサービスとしてのAEMへのデプロイ '
translation-type: tm+mt
source-git-commit: 44df22ace403c962ffbabac5eec9302d98fc94f2

---


# クラウドサービスとしてのAEMへのデプロイ {#deploying-to-aem-as-a-cloud-service}

## 概要 {#introduction}

コード開発の基本は、AEMのクラウドサービスとAEMのオンプレミスソリューションおよびマネージドサービスソリューションに似ています。 開発者はコードを書き込み、ローカルでテストし、その後クラウドサービス環境としてリモートAEMにプッシュされます。 Managed Servicesのオプションのコンテンツ配信ツールであるCloud Managerが必要です。 これが、クラウドサービス環境としてAEMにコードをデプロイするための唯一のメカニズムになりました。

AEMバージョンのアップデートは、カスタムコードをプッシュするのとは別のデプロイメントイベントです。 別の方法では、カスタムコードリリースが実稼働環境にあるAEMバージョンに対してテストされます。これは、カスタムコードリリースがその上にデプロイされるためです。 その後に発生するAEMバージョンの更新は、現在のマネージドサービスと比較して頻繁に適用されます。 これらは、既に導入済みの顧客コードとの下位互換性を確保することを目的としています。

このドキュメントの残りの部分では、開発者がクラウドサービスのバージョンの更新と顧客の更新の両方と連携するために、開発者がその慣行をどのように適応させるべきかについて説明します。

>[!NOTE]
>既存のコードベースを持つお客様は、 [AEMドキュメントで説明されているリポジトリ再構築の実習を実行することをお勧めします](https://docs.adobe.com/help/en/collaborative-doc-instructions/collaboration-guide/authoring/restructure.html)。


## AEMバージョンの更新 {#version-updates}

AEMは頻繁に（場合によっては1日に1回も）更新され、バグ修正とパフォーマンス強化に重点を置いて行われることを理解することが重要です。 更新は透過的に行われ、ダウンタイムは発生しません。 この更新は下位互換性を持つもので、カスタムコードを変更する必要はありません。 実際、AEMのアップデートは、顧客コードのデプロイメントから独立したイベントです。 AEMアップデートは、前回正常に完了したコードのプッシュの上にデプロイされます。これは、最後の実稼働へのプッシュ以降にコミットされた変更はデプロイされないことを意味します。

>[!NOTE]
>
> カスタムコードがステージングにプッシュされ、拒否された場合、次回のAEMの更新では、顧客が最後に正常にリリースした実稼動環境へのgitタグを反映するために、これらの変更が削除されます。

通常の頻度で、機能のリリースが行われ、毎日のリリースと比べてユーザー体験に大きな影響を与える機能の追加と機能強化に焦点を当てます。 機能リリースは、大きな変更セットの導入ではなく、リリースの切り替えを反転させて、毎日の更新を通じて日単位または週単位で蓄積されているコードをアクティブ化することでトリガーされます。

ヘルスチェックは、アプリケーションの状態を監視するために使用されます。 AEMのクラウドサービスの更新中にこれらのチェックが失敗した場合、その環境のリリースは続行されず、アドビは、アップデートがこの予期しない動作を引き起こした理由を調査します。

### 複合ノードストア {#composite-node-store}

上述のように、ノードのクラスターである作成者を含め、ほとんどの場合、アップデートにダウンタイムが発生しません。 Oakの「複合ノードストア」機能により、ローリング更新が可能です。 この機能を使用すると、AEMは複数のリポジトリを同時に参照できます。 ローリングデプロイメントでは、新しいGreen AEMバージョンに独自の `/libs` （TarMKベースの不変リポジトリ）が含まれ、古いBlue AEMバージョンとは異なりますが、両方とも、 `/content`、などの領域を含む共有DocumentMKベースの可変リポジトリを参照し `/conf`てい `/etc` ます。 青と緑の両方には独自のバージョンがあるので、ローリング更新中に両方ともアクティブになり、青が完全に緑に置き換えられるまでトラフィックが受け継がれます。 `/libs`

## お客様向けリリース {#customer-releases}

### 適切なAEMバージョンに対するコーディング {#coding-against-the-right-aem-version}

以前のAEMソリューションでは、最新のAEMバージョンは頻繁には変更されませんでした（四半期別のサービスパックを使用した場合、お客様は、API jarを参照して、実稼働インスタンスを最新のクイックスタートに更新します）。 ただし、クラウドサービスアプリケーションとしてのAEMは、最新バージョンのAEMにより頻繁に更新されるので、内部リリースのカスタムコードは、新しいAEMインターフェイスに対して構築する必要があります。

クラウド以外の既存のAEMバージョンと同様に、特定のクイックスタートに基づくローカルのオフライン開発がサポートされ、多くの場合、デバッグ用のツールとして選択されることが予想されます。

> [!注意}
>ローカルマシン上でのアプリケーションの動作とAdobe cloudとの間には、操作上のわずかな違いがあります。 これらのアーキテクチャの違いは、ローカル開発時に考慮する必要があり、クラウドインフラストラクチャに展開する際には、動作が異なる可能性があります。 これらの違いにより、実稼働環境で新しいカスタムコードを展開する前に、開発環境とステージ環境で完全なテストを実行することが重要です。

以下に、開発者がAEMアーティファクトの関連バージョンにアクセスするプロセスを示します。これを、内部リリースのカスタムコードの開発に必要なクラウドサービスSDKと呼びます。 ディスパッチャーに関する情報は、このペ [ージにあります](/help/implementing/dispatcher/overview.md)。

## Cloud ManagerとPackage Managerを使用したコンテンツパッケージの展開 {#deploying-content-packages-via-cloud-manager-and-package-manager}

### Cloud Managerを使用したデプロイメント {#deployments-via-cloud-manager}

お客様は、Cloud Managerを使用して、カスタムコードをクラウド環境にデプロイします。 Cloud Managerは、ローカルにアセンブリされたコンテンツパッケージをSling機能モデルに準拠したアーティファクトに変換することに注意してください。これは、クラウド環境で実行する場合の、クラウドサービスアプリケーションとしてのAEMの説明方法です。 その結果、Cloud環境のPackage Managerでパッケージを確認すると、名前に「cp2fm」が含まれ、変換されたパッケージではすべてのメタデータが削除されます。 これらは、ダウンロード、複製、または開くことができないため、操作を行うことはできません。 コンバーターに関する詳細なドキュメントは、こちら [を参照してくださ](https://github.com/apache/sling-org-apache-sling-feature-cpconverter)い。

AEM用にクラウドサービスアプリケーションとして作成されたコンテンツパッケージは、不変コンテンツと可変コンテンツを明確に区切る必要があり、Cloud Managerはビルドに失敗し、次のようなメッセージを出力します。

`Generated content-package <PACKAGE_ID> located in file <PATH> is of MIXED type`

この節の残りの部分では、不変パッケージと可変パッケージの構成と意味について説明します。

### 不変コンテンツパッケージ {#immutabe-content-packages}

不変リポジトリに保持されるすべてのコンテンツとコードは、gitにチェックインし、Cloud Managerを使用してデプロイする必要があります。 つまり、現在のAEMソリューションとは異なり、実行中のAEMインスタンスにコードが直接デプロイされることはありません。 これにより、任意のCloud環境で特定のリリースに対して実行されるコードが同じになり、意図しないコードの変動が実稼働環境で発生するリスクを排除できます。 例えば、OSGI設定は、実行時にAEM webコンソールのConfiguration Manager経由で管理されるのではなく、ソース管理にコミットする必要があります。

青 — 緑のデプロイメントパターンによるアプリケーションの変更はスイッチによって有効にされるので、サービスユーザー、ACL、ノードタイプ、インデックス定義の変更を除き、可変リポジトリの変更に依存することはできません。

既存のコードベースを使用するお客様の場合は、AEMドキュメントで説明されているリポジトリの再構築の演習を実行し、/etcの下にあったコンテンツが適切な場所に確実に移動されるようにすることが重要です。

## OSGI設定 {#osgi-configuration}

上述のように、OSGI設定はWebコンソールを通じてではなく、ソース管理にコミットする必要があります。 そのための手順は次のとおりです。

* AEM webコンソールのConfiguration Managerを使用して開発者のローカルAEM環境に必要な変更を加え、その結果をローカルファイルシステム上のAEMプロジェクトに書き出します
* ローカルファイルシステム上のAEMプロジェクトでOSGI設定を手動で作成し、AEMコンソールの設定マネージャーでプロパティ名を参照します。

## 可変コンテンツ {#mutable-content}

場合によっては、環境が更新されたときにCloud Managerでデプロイできるように、ソース管理でコンテンツの変更を準備すると役に立つことがあります。 例えば、特定のルートフォルダー構造をシードしたり、編集可能なテンプレートに変更を整列させて、アプリケーションのデプロイメントによって更新されたコンポーネントのポリシーを有効にしたりするのが妥当な場合があります。

Cloud Managerが可変リポジトリにデプロイするコンテンツ、可変コンテンツパッケージ、およびレポイント文を記述する方法は2つあります。

### 可変コンテンツパッケージ {#mutable-content-packages}

フォルダーパス階層、サービスユーザー、アクセス制御(ACL)などのコンテンツは、通常、MavenアーキタイプベースのAEMプロジェクトにコミットされます。 この手法には、AEMから書き出す、またはXMLとして直接書き込むなどがあります。 構築と展開のプロセス中に、Cloud Managerは、生成される可変コンテンツパッケージをパッケージ化します。 可変コンテンツは、パイプラインの展開段階で3回異なる時間にインストールされます。

新しいバージョンのアプリケーションの起動前：

* インデックス定義（追加、変更、削除）

新しいバージョンのアプリケーションの起動中、ただしスイッチオーバーの前に：

* サービスユーザー（追加）
* サービスユーザーACL（追加）
* ノードタイプ（追加）

新しいバージョンのアプリケーションに切り替えた後：

* Jackrabbit vaultを介して定義可能なその他すべてのコンテンツ。 次に例を示します。
   * フォルダ（追加、変更、削除）
   * 編集可能なテンプレート（追加、変更、削除）
   * コンテキスト対応設定( `/conf`以下のもの)（追加、変更、削除）
   * スクリプト（パッケージは、パッケージのインストールプロセスの様々な段階でインストールフックをトリガーできます）

可変コンテンツのインストールを作成者に制限したり、発行に制限したりするには、のinstall.authorフォルダーまたはinstall.publishフォルダーにパッケージを埋め込みま `/apps`す。 推奨されるプロジェクトの再構築に関する詳細は、 [AEMドキュメント](https://docs.adobe.com/content/help/en/experience-manager-65/deploying/restructuring/repository-restructuring.html) （英語のみ）を参照してください。

>[!NOTE] コンテンツパッケージは、すべての環境タイプ（開発、ステージ、実稼動）に展開されます。 特定の環境に展開を制限することはできません。 この制限は、自動実行のテスト実行のオプションを確実にするために適用されます。 環境に固有のコンテンツは、Package Managerを使用して手動でインストールする必要があります。

また、可変コンテンツパッケージの変更が適用された後に、その変更をロールバックするメカニズムはありません。 お客様が問題を検出した場合は、次回のコードリリースで修正するか、最後の手段としてシステム全体を展開前の時点に復元するかを選択できます。

含まれるサードパーティパッケージは、クラウドサービスサービスと互換性があるAEMとして検証する必要があります。検証しないと、パッケージを含めるとデプロイメントエラーが発生します。

上記のように、既存のコードベースを持つお客様は、 [AEMドキュメントで説明されているリポジトリ再構築の演習に準拠する必要があります](https://helpx.adobe.com/experience-manager/6-5/sites/deploying/using/repository-restructuring.html)。

## レポイント {#repoinit}

次の場合は、OSGIファクトリ設定で明示的なコンテンツ作成文を手動でコーディングするアプローチを `repoinit` とることをお勧めします。

* サービスユーザーの作成/削除/無効化
* グループの作成/削除
* ユーザーの作成/削除
* ACLの追加
   > [!NOTE] ACLの定義では、ノード構造が既に存在する必要があります。 したがって、先行するcreate pathステートメントが必要になる場合があります。
* パスの追加（例えば、ルートフォルダー構造）
* CNDの追加（ノードタイプの定義）

次の利点があるため、サポートされているコンテンツの変更の使用例においては、レポイントをお勧めします。

* Repoinitは、起動時にリソースを作成し、論理がそれらのリソースの存在を当たり前と考えられるようにします。 可変コンテンツパッケージアプローチでは、リソースは起動後に作成されるので、リソースに依存するアプリケーションコードが失敗する可能性があります。
* 実行するアクションを明示的に制御するので、比較的安全な命令セットです。 また、サポートされている操作は追加的なものですが、セキュリティ関連のいくつかの例を除き、ユーザー、サービスユーザーおよびグループを削除できます。 これに対し、可変コンテンツパッケージアプローチでの何かの削除は明示的です。 フィルターを定義すると、フィルターの対象となるすべての要素が削除されます。 ただし、コンテンツが新しいコンテンツの場合は、アプリケーションの動作が変わる可能性があるので、注意が必要です。
* レポイントは高速でアトミックな操作を実行します。 対照的に可変コンテンツパッケージは、フィルターで覆われる構造によってパフォーマンスが大きく左右される場合があります。 単一のノードを更新した場合でも、大きなツリーのスナップショットが作成される場合があります。
* OSGi設定が登録されると実行されるので、ローカル開発環境でのレポイント文を実行時に検証できます。
* レポイント文はアトミックで明示的で、状態が既に一致する場合はスキップします。

Cloud Managerがアプリケーションをデプロイする際に、コンテンツパッケージのインストールとは独立して、これらの文が実行されます。

レポイント文を作成するには、次の手順に従います。

1. プロジェクトの設定フォ `org.apache.sling.jcr.repoinit.RepositoryInitializer` ルダーにPIDのOSGi設定を追加
1. 設定のスクリプトプロパティにレポイント文を追加します。 構文とオプションは [Slingのドキュメントに記載されています](https://sling.apache.org/documentation/bundles/repository-initialization.html)。 子フォルダーの前に、親フォルダーを明示的に作成する必要があります。 例えば、before, `/content` beforeの明示的 `/content/myfolder`な作成 `/content/myfolder/mysubfolder`。 ACLを低レベルの構造に設定する場合は、それらを高レベルに設定し、制限を設定することをお勧めし `rep:glob` ます。  For example `(allow jcr:read on /apps restriction(rep:glob,/msm/wcm/rolloutconfigs))`.
1. 実行時にローカル開発環境で検証します。

<!-- last statement in step 2 to be clarified with Brian -->

>[!WARNING]
>
>下位ノードに定義されたACLの場合、ま `/apps` たはレポ `/libs` イントの実行は、空白のリポジトリで開始されます。 パッケージは、指定の後にインストールされるので、文はパッケージ内で定義されたものに依存することはできませんが、その下の親構造のような前提条件を定義する必要があります。

>[!TIP]
>
>ACLの場合、ディープ構造の作成は面倒になる可能性があるので、より高いレベルでACLを定義し、rep:glob制限を使用して動作するべき場所を制限する方が適切です。

レポイントの詳細については、 [Slingのドキュメントを参照してください](https://sling.apache.org/documentation/bundles/repository-initialization.html)

<!-- ### Packaging of Immutable and Mutable Packages {#packaging-of-immutable-and-mutable-packages}

above appears to be internal, to confirm with Brian -->

### 可変コンテンツパッケージのPackage Managerの「1つの機能」 {#package-manager-oneoffs-for-mutable-content-packages}

コンテンツパッケージを「1つ」としてインストールする必要がある場合があります。 例えば、実稼働環境の問題をデバッグするために、実稼働環境からステージングに特定のコンテンツをインポートします。 これらのシナリオでは、Package Managerをクラウドサービス環境としてAEMで使用できます。

Package Managerはランタイムの概念なので、不変リポジトリにコンテンツやコードをインストールすることはできないので、これらのコンテンツパッケージは可変コンテンツ(主にまたは `/content``/conf`)のみで構成する必要があります。 コンテンツパッケージに混在するコンテンツ（可変コンテンツと不変コンテンツの両方）が含まれる場合、可変コンテンツのみがインストールされます。

Cloud Manager（可変および不変の両方）を使用してインストールされたコンテンツパッケージは、AEM Package Managerのユーザーインターフェイスにフリーズ状態で表示されます。 これらのパッケージは再インストール、再構築、またはダウンロードすることはできません。また、 **cp2fm** というサフィックスが付いており、そのインストールがCloud Managerで管理されていることを示しています。

### サードパーティパッケージを含む {#including-third-party}

アドビの翻訳パートナーなどのソフトウェアベンダーのサードパーティソースからの事前ビルドパッケージを含めるのは、お客様にとって一般的です。 これらのパッケージをリモートリポジトリでホストし、それらをで参照することをお勧めしま `pom.xml`す。 これは、パブリックリポジトリに対してのみ可能です。

パッケージをリモートリポジトリに格納できない場合は、SCMにプロジェクトの一部としてコミットされ、依存する任意の要素によって参照される、ローカルのファイルシステムベースのMavenリポジトリに配置できます。 リポジトリは、次に示すプロジェクトポーマで宣言されます。


```
<repository>
    <id>project.local</id>
    <name>project</name>
    <url>file:${maven.multiModuleProjectDirectory}/repository</url>
</repository>
```

<!-- formatting appears broken in the code sample above, check how it appears on AEM -->

含まれるサードパーティパッケージは、この記事で説明するクラウドサービスのコーディングおよびパッケージングのガイドラインとしてAEMに準拠する必要があります。それ以外の場合は、パッケージを含めるとデプロイメントに失敗します。

次のMaven POM XMLスニペットは、サードパーティパッケージをプロジェクトの「コンテナ」パッケージに埋め込む方法を示しています。通常は、「 **all**」という名前が付きます( **filevault-package-maven-plugin** Mavenプラグインの設定を使用)。

```
...
<plugin>
  <groupId>org.apache.jackrabbit</groupId>
  <artifactId>filevault-package-maven-plugin</artifactId>
  <extensions>true</extensions>
  <configuration>
      ...
      <subPackages>
           
          <!-- Include the application's ui.apps and ui.content packages -->
          ...
 
          <!-- Include any other extra packages such as AEM WCM Core Components -->
          <!-- Set the version for all dependencies, including 3rd party packages, in the project's Reactor POM -->
          <subPackage>
              <groupId>com.adobe.cq</groupId>
              <artifactId>core.wcm.components.all</artifactId>
              <filter>true</filter>
          </subPackage>
 
 
          <subPackage>
              <groupId>com.3rdparty.groupId</groupId>
              <artifactId>core.3rdparty.artifactId</artifactId>
              <filter>true</filter>
          </subPackage>
      <subPackages>
  </configuration>
</plugin>
...
```

## ローリングデプロイメントの仕組み {#how-rolling-deployments-work}

AEMのアップデートと同様に、お客様向けリリースも、適切な状況での作成者クラスターのダウンタイムを解消するために、ローリングデプロイメント戦略を使用してデプロイされます。 イベントの一般的なシーケンスを次に示します。 **Blue** は顧客コードの古いバージョン、 **Green** は新しいバージョンです。 青と緑の両方で同じバージョンのAEMコードが実行されています。

* 青のバージョンがアクティブで、緑のリリース候補が構築され、利用可能
* 新しいインデックス定義または更新されたインデックス定義がある場合は、対応するインデックスが処理されます。 青の展開では常に古いインデックスが使用され、緑の展開では常に新しいインデックスが使用されます。
* 青がまだ提供中に緑が起動
* 稼働状態の確認による準備が整っているかどうかを確認中に、青が実行中で、処理中です
* 準備が整った緑のノードはトラフィックを受け入れ、青のノードを置き換えます。これはダウンします。
* 時間の経過と共に、青のノードは緑のノードのみが残るまで緑のノードに置き換えられ、デプロイが完了します
* 新しい、または変更された可変コンテンツがデプロイされる

## Indexes {#indexes}

新しい（緑色の）バージョンでトラフィックを受け取る前に、新しいインデックスまたは変更されたインデックスは、インデックス作成または再インデックスの手順を引き起こします。 Skylineのインデックス管理について詳しくは、この記事を参照し [てください](/help/operations/indexing.md)。 Cloud Managerビルドページでインデックスジョブの状態を確認でき、新しいバージョンでトラフィックを受け取る準備ができたら通知を受け取ります。

>[!NOTE]
>
>ローリング展開に必要な時間は、インデックスのサイズによって異なります。新しいインデックスが生成されるまで、Greenバージョンはトラフィックを受け入れられないからです。

現時点では、SkylineはACS Commons Ensure Oak indexツールなどのインデックス管理ツールでは機能しません。

## レプリケーション {#replication}

このパブリケーションメカニズムは、 [AEM Replication Java APIと下位互換性があります](https://helpx.adobe.com/experience-manager/6-3/sites/developing/using/reference-materials/diff-previous/changes/com.day.cq.replication.Replicator.html)。

クラウド対応のAEM Quickstartを使用したレプリケーションを使用して開発およびテストするには、従来のレプリケーション機能を作成者/発行のセットアップで使用する必要があります。 AEM AuthorのUIエントリポイントがクラウドから削除された場合、ユーザーは設定に移動 `http://localhost:4502/etc/replication` します。

## ローリングデプロイメント用の下位互換コード {#backwards-compatible-code-for-rolling-deployments}

上述のように、AEMはクラウドサービスのローリングデプロイメント戦略では、古いバージョンと新しいバージョンの両方が同時に動作する可能性があることを意味します。 したがって、動作中の古いAEMバージョンとの下位互換性がないコード変更には注意が必要です。

また、ロールバック時に新しいリリースで適用される可変コンテンツ構造との互換性については、可変コンテンツは削除されないので、古いリリースでテストする必要があります。

### サービスユーザーとACLの変更 {#service-users-and-acl-changes}

コンテンツやコードにアクセスするために必要なサービスユーザーやACLを変更すると、古いAEMバージョンでエラーが発生し、古いサービスユーザーを含むコンテンツやコードにアクセスできる場合があります。 この動作に対処するには、少なくとも2つのリリースにわたって変更を行い、最初のリリースをブリッジとして機能させてから、後続のリリースでクリーンアップすることをお勧めします。

### 索引の変更 {#index-changes}

インデックスに変更を加えた場合、Blueバージョンは終了するまでインデックスを引き続き使用し、Greenバージョンは独自の変更済みインデックスのセットを使用します。 開発者は、この記事で説明するインデックス管理手法に従 [う必要があります](/help/operations/indexing.md)。

### ロールバックの保守的なコーディング {#conservative-coding-for-rollbacks}

展開後にエラーが報告または検出された場合は、Blueバージョンへのロールバックが必要になる可能性があります。 新しい構造（可変コンテンツ）はロールバックされないので、BlueコードがGreenバージョンで作成された新しい構造と互換性があることを確認してください。 古いコードに互換性がない場合は、以降のお客様向けリリースで修正を適用する必要があります。

## Runmodes {#runmodes}

既存のAEMソリューションでは、お客様は任意の実行モードでインスタンスを実行し、OSGI設定を適用したり、OSGIバンドルを特定のインスタンスにインストールしたりするオプションがあります。 通常、定義される実行モードには *サービス* （作成者および公開）と環境（開発、ステージ、製品）が含まれます。

一方、AEM as a Cloud Serviceは、利用可能な実行モードと、OSGIバンドルとOSGI設定のマッピング方法についての意見が強くなります。

* OSGI設定の実行モードは、環境または作成者用に開発、ステージ、prodを参照し、サービス用に発行する必要があります。 の組み合わせ `<service>.<environment_type>` がサポートされていますが、これらの組み合わせはこの特定の順序で使用する必要があります（例えば、author.devやpublish.prod）。 OSGIトークンは、メソッドを使用する代わりに、コードから直接参照する必要があ `getRunModes` ります。これにより、実行時にはこのトークンは含ま `environment_type` れなくなります。
* OSGIバンドルの実行モードは、サービス（作成者、発行）に制限されます。 実行ごとのモードのOSGIバンドルは、またはの下のコンテンツパッケージにインストールする必要が `install/author` ありま `install/publish`す。

既存のAEMソリューションと同様に、実行モードを使用して特定の環境やサービスのコンテンツのみをインストールする方法はありません。 ステージまたは実稼働環境にないデータまたはHTMLを使用して開発環境をシードする必要がある場合は、パッケージマネージャーを使用できます。

サポートされている実行モードの設定は次のとおりです。

* **config** (デフ&#x200B;*ォルトで、すべてのAEMサービスに適用されます*)
* **config.author** (すべての&#x200B;*AEM authorサービスに適用*)
* **config.author.dev** (AEM Dev Author *サービスに適用*)
* **config.author.stage** (AEMステ&#x200B;*ージングAuthorサービスに適用*)
* **config.author.prod** (AEM Production Author *サービスに適用*)
* **config.publish** (AEM publish *サービスに適用*)
* **config.publish.dev** (AEM Dev Publish *サービスに適用*)
* **config.publish.stage** (AEM Staging Publish *サービスに適用*)
* **config.publish.prod** (AEM Production Publish *サービスに適用*)
* **config.dev** （*AEM devサービスに適用）
* **config.stage** （*AEMステージングサービスに適用）
* **config.prod** （*AEM Productionサービスに適用）

最も一致する実行モードを持つOSGI設定が使用されます。

ローカルで開発する際には、runmode起動パラメータを渡して、OSGIのどの実行モード設定を使用するかを指定できます。

<!-- ### Performance Monitoring {#performance-monitoring}

Developers want to ensure that their custom code is performing well. For Cloud environments, performance reports can be viewed on Cloud Manager. -->

## ソース管理のメンテナンスタスク設定 {#maintenance-tasks-configuration-in-source-control}

ツール/操作画面はCloud環境で使用できなくなるので、保守 **タスクの設定は** 、ソース管理で維持する必要があります。 これは、変更が反映されたり忘れられたりするのではなく、意図的に永続的に行われるというメリットがあります。 詳しくは、「メンテナンス [タスク」の記事を参照](/help/operations/maintenance.md) してください。
