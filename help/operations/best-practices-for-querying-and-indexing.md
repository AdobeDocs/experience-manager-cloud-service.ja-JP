---
title: クエリとインデックスに関するベストプラクティス
seo-title: Best Practices for Queries and Indexing
description: この記事では、インデックスとクエリを最適化する方法についてのガイドラインを提供します。
seo-description: This article provides guidelines on how to optimize your indexes and queries.
topic-tags: best-practices
source-git-commit: 85cbdaa6e6d01856005cb47f289d391fb44bd65e
workflow-type: tm+mt
source-wordcount: '1573'
ht-degree: 38%

---


# クエリとインデックスに関するベストプラクティス{#best-practices-for-queries-and-indexing}

AEMの以前のバージョンとは異なり、インデックス作成に関する運用上の側面はすべて自動化されています。 これにより、開発者は、効率的なクエリと、それに対応するインデックス定義の作成に専念できます。

## クエリを使用するタイミング {#when-to-use-queries}

クエリはコンテンツにアクセスする方法ですが、唯一の方法ではありません。 そのため、コンテンツにアクセスする最も高いパフォーマンスを発揮する方法がクエリである場合は、クエリを評価する必要があります。 多くの場合、他の方法では、リポジトリ内のコンテンツへのアクセスパフォーマンスが向上します。

### リポジトリと分類の設計 {#repository-and-taxonomy-design}

リポジトリの分類を設計する際は、いくつかの要素を考慮する必要があります。要素には、アクセス制御、ローカリゼーション、コンポーネントおよびページプロパティの継承などがあります。

こうした事柄に対応する分類を設計する一方で、インデックス設計の「トラバーサビリティ」についても検討することも重要です。トラバーサビリティとは、この文脈では、パスに基づいて予想どおりにコンテンツにアクセスできるようにする分類の機能を言います。トラバーサビリティは、多数のクエリの実行が必要なシステムに比べて保守が簡単な、よりパフォーマンスの高いシステムの実現に役立ちます。

さらに分類を設計する際は、順序が重要かどうか検討することが重要です。明確な順序が不要な場合および多数の兄弟ノードが予想される場合は、`sling:Folder` や `oak:Unstructured` などの順序がないノードタイプを使用することを推奨します。順序付けが必要な場合は、`nt:unstructured` および `sling:OrderedFolder` の方が適切です。

### コンポーネント内のクエリ {#queries-in-components}

クエリは、AEM システムで実行される際の負荷が比較的大きい処理なので、コンポーネント内のクエリはできる限り避けるようにします。ページがレンダリングされるたびに複数のクエリを実行すると、システムのパフォーマンス低下につながります。コンポーネントのレンダリング時にクエリが実行されることを回避するには、**ノードの走査**&#x200B;と&#x200B;**結果の先取り**&#x200B;という 2 つの方法があります。

### ノードの走査 {#traversing-nodes}

必要なデータの場所を事前に把握できるように設計されたリポジトリの場合は、データを発見するためのクエリを実行する必要はなく、そのデータを必要なパスから取得するコードをデプロイできます。

例として考えられるのは、特定のカテゴリに適合するコンテンツをレンダリングする場合です。これを実現する 1 つの方法は、コンテンツをカテゴリプロパティで整理し、このプロパティをクエリして、カテゴリ内のアイテムを表示するコンポーネントに割り当てることです。

もっと良い方法は、コンテンツをカテゴリ別の分類で構造化し、コンテンツを手動で取得できるようにすることです。

例えば、コンテンツが以下の場所に似た分類で格納されている場合は、

```xml
/content/myUnstructuredContent/parentCategory/childCategory/contentPiece
```

`/content/myUnstructuredContent/parentCategory/childCategory` ノードは簡単に取得でき、その子ノードを解析してコンポーネントのレンダリングに使用できます。

さらに、小規模または一様なデータセットを扱う場合は、同じ結果セットを返すためにクエリを作成するよりも、リポジトリを走査して必要なノードを収集するほうが速い場合があります。一般論として、クエリはできる限り使用せずに済ませることを推奨します。

### 結果の先取り {#prefetching-results}

コンテンツやコンポーネントの要件によっては、必要なデータを取得する方法としてノードの走査を使用できない場合があります。この場合、最適なパフォーマンスを確保するために、必要なクエリをコンポーネントがレンダリングされる前に実行する必要があります。

コンポーネントに必要な結果が、作成時に計算でき、コンテンツが変更される予測がない場合は、変更後にクエリを実行できます。

データまたはコンポーネントが定期的に変更される場合は、スケジュールに従って、または基礎データの更新リスナーを使用してクエリを実行できます。クエリの結果は、リポジトリ内の共有の場所に書き込むことができます。このデータを必要とするコンポーネントは、実行時にクエリを実行しなくても、この 1 つのノードから値を取り出すことが可能です。同様の方法を使用して、結果をメモリ内キャッシュに保持できます。このキャッシュは、起動時に入力され、変更がおこなわれるたびに（JCR ObservationListener または Sling ResourceChangeListener を使用して）更新されます。

## クエリの最適化 {#optimizing-queries}

Oak ドキュメントでは、 [クエリの実行方法の概要](https://jackrabbit.apache.org/oak/docs/query/query-engine.html#query-processing). これは、このドキュメントで説明するすべての最適化アクティビティの基礎となります。

AEM as a Cloud Service は、効率的なクエリの実装をサポートするように設計されたクエリパフォーマンスツールを提供します。
* 実行済みのクエリと、関連するパフォーマンス特性およびクエリプランが表示されます。
* クエリプランの表示から完全なクエリの実行まで、様々なレベルでアドホッククエリを実行できます。

クエリパフォーマンスツールには、 [Cloud Manager の開発者コンソール](https://experienceleague.adobe.com/docs/experience-manager-learn/cloud-service/debugging/debugging-aem-as-a-cloud-service/developer-console.html?lang=ja#queries). AEM 6.x の以前のバージョンのクエリパフォーマンスツールとは異なり、AEM as a Cloud Service向けのパフォーマンスクエリツールは、クエリの実行の詳細に関する詳細を提供します。クエリの改善に役立ちます。


クエリパフォーマンスツールを使用してクエリを最適化する一般的な方法について、このグラフで説明します。
![クエリ最適化フロー](assets/query-optimization-flow.png)



### インデックスの使用 {#use-an-index}

最適なパフォーマンスを実現するには、すべてのクエリでインデックスを使用する必要があります。 既存の標準提供インデックスが存在する場合は、ほとんどの場合、クエリを処理するのに十分です。
既存のインデックスにカスタムプロパティを追加する必要が生じる場合があるので、このインデックスを使用して追加の制約を照会できます。 詳しくは、 [コンテンツの検索とインデックス作成](/help/operations/indexing.md#changing-an-index) を参照してください。 この [JCR クエリのチートシート](#jcr-query-cheatsheet) 特定のクエリタイプをサポートするために、インデックスのプロパティ定義がどのように表示されるかを説明します。



### 適切な条件を使用

クエリの主な制約は、プロパティの一致である必要があります。これは最も効率的な型です。 プロパティの制約を追加すると、結果はさらに絞り込まれます。
クエリエンジンは単一のインデックスのみを考慮します。つまり、既存のインデックスにカスタムインデックスプロパティを追加することで、既存のインデックスをカスタマイズでき、カスタマイズする必要があります。

この [JCR クエリのチートシート](#jcr-query-cheatsheet) 使用可能な制約を示し、インデックス定義が取得されるようにするためのインデックス定義の外観の概要も示します。 以下を使用： [クエリパフォーマンスツール](#query-performance-tool) を使用してクエリをテストし、適切なインデックスが使用され、クエリエンジンがインデックス外の制約を評価する必要がないことを確認します。


### 順序

結果の特定の順序がリクエストされた場合、クエリエンジンでこれを実現する方法は 2 つあります。

1. インデックスを使用すると、結果を完全に正しい順序で配信できます。順序付けに使用されるプロパティに ```ordered=true``` を使用します。
2. クエリエンジンがインデックスの外部でフィルタリングを実行する必要がある場合、または順序プロパティに ```ordered=true``` プロパティを使用する場合、クエリエンジンも順序付けプロセスを実行します。 この場合、結果セット全体が並べ替えのためにメモリに読み込まれる必要がありますが、最初のオプションよりはるかに時間がかかります。





### 結果のサイズを制限

クエリ結果の取得サイズは、クエリパフォーマンスの重要な要因です。 結果は遅延的に取得されるので、ランタイムとメモリの両方で、10,000 個の結果を取得する場合と比較して、最初の 20 個の結果を取得する場合に違いがあります。

つまり、すべての結果が取得された場合、結果セットのサイズが正しく判別されるだけです。 このため、取得する結果セットは、クエリを拡張することで常に制限される必要があります ( [JCR クエリのチートシート](#jcr-query-cheatsheet) （詳細を参照）、または結果の読み取りを制限する方法について説明します。
このような制限は、クエリエンジンが **横断限界** 100,000 個のノードで構成され、クエリが強制的に停止します。

の節を参照してください。 [結果の大きいクエリ](#queries-with-large-result-sets) の下に、サイズが大きい可能性のある結果セットを完全に処理する必要がある場合を示します。


## JCR クエリのチートシート

効率的な JCR クエリとインデックス定義を作成できるようにするため、開発時に [JCR クエリチートシート](https://experienceleague.adobe.com/docs/experience-manager-65/deploying/practices/best-practices-for-queries-and-indexing.html#jcrquerycheatsheet)をダウンロードして参照用として使用できます。これには QueryBuilder、XPath、SQL-2 のクエリの例が収録されていて、クエリのパフォーマンスの点で異なる動作をする複数のシナリオに対応できます。また、Oak インデックスの作成またはカスタマイズ方法に関する推奨事項も収録されています。このチートシートの内容は、AEM 6.5 および AEM as a Cloud Service に適用されます。


## 大きな結果セットを持つクエリ

結果が大きいクエリは避けることをお勧めしますが、大きな結果を処理する必要がある場合もあります。 結果のサイズが事前にわからない場合が多いので、処理を信頼できるものにするために、いくつかの注意事項を講じる必要があります。

* クエリはリクエスト内で実行しないでください。代わりに、Sling ジョブまたはAEMワークフローの一部としてクエリを実行する必要があります。 これらは、合計実行時間に制限がなく、クエリとその結果の処理中にインスタンスが停止した場合に備えて、再び開始されます。
* 100,000 個の読み取りノードのクエリ制限を克服するには、を使用することを検討する必要があります。 [キーセットのページネーション](https://jackrabbit.apache.org/oak/docs/query/query-engine.html#Keyset_Pagination) クエリを複数のサブクエリに分割します。



## リポジトリを走査するクエリ

リポジトリを走査するクエリはインデックスを使用せず、次のようなメッセージを記録します。

```text
28.06.2022 13:32:52.804 *WARN* [127.0.0.1 [1656415972414] POST /libs/settings/granite/operations/diagnosis/granite_queryperformance.explain.json HTTP/1.1] org.apache.jackrabbit.oak.plugins.index.Cursors$TraversingCursor Traversed 98000 nodes with filter Filter(query=select [jcr:path], [jcr:score], * from [nt:base] as a /* xpath: //* */, path=*) called by com.adobe.granite.queries.impl.explain.query.ExplainQueryServlet.getHeuristics; consider creating an index or changing the query
```

このログスニペットには、次の関連情報が含まれます。

* クエリ自体： ```//* ```
* このクエリを実行した java コード： ```com.adobe.granite.queries.impl.explain.query.ExplainQueryServlet::getHeuristics```;これは、このクエリの作成者を特定するのに役立ちます。

この情報を使用すると、 [クエリの最適化](#optimizing-queries).