---
title: クエリとインデックス作成のベストプラクティス
description: アドビのベストプラクティスガイドラインに基づいてインデックスとクエリを最適化する方法を説明します。
topic-tags: best-practices
exl-id: 37eae99d-542d-4580-b93f-f454008880b1
source-git-commit: afeff7cfb8606eb58126a4ca62ce9e6e58c44215
workflow-type: tm+mt
source-wordcount: '1563'
ht-degree: 100%

---

# クエリとインデックス作成のベストプラクティス {#query-and-indexing-best-practices}

AEM as a Cloud Service では、インデックス作成に関わる様々な操作はすべて自動化されています。これにより、開発者は効率的なクエリの作成とそれに対応するインデックスの定義に専念できます。

## クエリを使用する場面 {#when-to-use-queries}

クエリを使用するとコンテンツにアクセスできますが、唯一の手段ではありません。多くの場合、他の手段でもより効率的にリポジトリ内のコンテンツにアクセスできます。クエリが使用例のコンテンツにアクセスするための最善かつ最も効率的な方法であるかどうかを検討する必要があります。

### リポジトリと分類の設計 {#repository-and-taxonomy-design}

リポジトリの分類を設計する際は、いくつかの要素を考慮する必要があります。考慮すべき点には、アクセス制御、ローカリゼーション、コンポーネント、ページプロパティの継承などが含まれます。

こうした事柄に対応する分類を設計する一方で、インデックス設計の「トラバーサビリティ」についても検討することも重要です。ここで、トラバーサビリティとは、パスに基づいて予測どおりにコンテンツにアクセスできる、分類が持つ能力のことです。これにより、より効率的なシステムが実現し、複数のクエリを実行する必要があるシステムよりも保守が容易になります。

さらに分類を設計する際は、順序が重要かどうか検討することが重要です。明確な順序が不要な場合および多数の兄弟ノードが予想される場合は、`sling:Folder` や `oak:Unstructured` などの順序がないノードタイプを使用することを推奨します。順序付けが必要な場合は、`nt:unstructured` および `sling:OrderedFolder` の方が適切です。

### コンポーネント内のクエリ {#queries-in-components}

クエリは、AEM システムで実行される際の負荷が比較的大きい処理なので、コンポーネント内のクエリはできる限り避けるようにします。ページがレンダリングされるたびに複数のクエリを実行すると、システムのパフォーマンス低下につながります。コンポーネントのレンダリング時にクエリが実行されることを回避するには、**[ノードの走査](#traversing-nodes)**&#x200B;と&#x200B;**[結果の先取り](#prefetching-results)**&#x200B;という 2 つの方法があります。

### ノードの走査 {#traversing-nodes}

必要なデータの場所を事前に把握できるように設計されたリポジトリの場合は、データを発見するためのクエリを実行する必要はなく、そのデータを必要なパスから取得するコードをデプロイできます。

例として考えられるのは、特定のカテゴリに適合するコンテンツをレンダリングする場合です。これを実現する 1 つの方法は、コンテンツをカテゴリプロパティで整理し、このプロパティをクエリして、カテゴリ内のアイテムを表示するコンポーネントに割り当てることです。

もっと良い方法は、コンテンツをカテゴリ別の分類で構造化し、コンテンツを手動で取得できるようにすることです。

例えば、コンテンツが以下の場所に似た分類で格納されている場合は、

```xml
/content/myUnstructuredContent/parentCategory/childCategory/contentPiece
```

`/content/myUnstructuredContent/parentCategory/childCategory` ノードは簡単に取得でき、その子ノードを解析してコンポーネントのレンダリングに使用できます。

さらに、小規模または一様なデータセットを扱う場合は、同じ結果セットを返すためにクエリを作成するよりも、リポジトリを走査して必要なノードを収集するほうが速い場合があります。一般論として、クエリはできる限り使用せずに済ませることを推奨します。

### 結果の先取り {#prefetching-results}

コンテンツやコンポーネントの要件によっては、必要なデータを取得する方法としてノードの走査を使用できない場合があります。このような場合は、最適なパフォーマンスを保証するために、コンポーネントがレンダリングされる前に必要なクエリを実行する必要があります。

コンポーネントで必要とされる結果をオーサリング時にまとめて計算でき、さらにコンテンツがその後も変更されないとわかっている場合は、変更が行われた後にクエリを実行できます。

データまたはコンポーネントが定期的に変更される場合は、スケジュールに従って、または基礎データの更新リスナーを使用してクエリを実行できます。クエリの結果は、リポジトリ内の共有の場所に書き込むことができます。このデータを必要とするコンポーネントは、実行時にクエリを実行しなくても、この 1 つのノードから値を取り出すことが可能です。

同様の方法を使用して、メモリ内キャッシュに結果を保持することができ、起動時にデータが取り込まれ、変更が行われるたびに更新されるようにできます（JCR `ObservationListener` または Sling `ResourceChangeListener` を使用）。

## クエリの最適化 {#optimizing-queries}

Oak ドキュメントでは、[クエリの実行方法の概要が説明されています。](https://jackrabbit.apache.org/oak/docs/query/query-engine.html#query-processing) これは、このドキュメントで説明するすべての最適化アクティビティの基礎となります。

AEM as a Cloud Service には、効率的なクエリの実装をサポートするように設計されたクエリパフォーマンスツールが用意されています。

* 実行済みのクエリと、関連するパフォーマンス特性およびクエリプランが表示されます。
* クエリプランの表示から完全なクエリの実行まで、様々なレベルでアドホッククエリを実行できます。

クエリパフォーマンスツールは、Cloud Manager の[開発者コンソールからアクセスできます。](https://experienceleague.adobe.com/docs/experience-manager-learn/cloud-service/debugging/debugging-aem-as-a-cloud-service/developer-console.html?lang=ja#queries) AEM as a Cloud Service のクエリパフォーマンスツールでは、AEM 6.x バージョンに対するクエリの実行に関する詳細が提供されます。

このグラフは、クエリパフォーマンスツールを使用してクエリを最適化するための一般的なフローを示しています。

![クエリ最適化フロー](assets/query-optimization-flow.png)

### インデックスの使用 {#use-an-index}

最適なパフォーマンスを実現するには、すべてのクエリでインデックスを使用する必要があります。ほとんどの場合、既存の標準提供インデックスで十分クエリを処理することができます。

時には、既存のインデックスにカスタムプロパティを追加する必要があり、インデックスを使用して追加の制約をクエリできるようになります。詳しくは、[コンテンツ検索とインデックス作成](/help/operations/indexing.md#changing-an-index)のドキュメントを参照してください。このドキュメントの [JCR クエリのチートシート](#jcr-query-cheatsheet)セクションでは、特定のクエリタイプをサポートするために、インデックスのプロパティ定義がどのように見える必要があるかについて説明します。

### 適切な条件を使用 {#use-the-right-criteria}

クエリの主な制約は、プロパティの一致である必要があり、これは最も効率的なタイプであるためです。プロパティ制約をさらに追加すると、結果をさらに絞り込めます。

クエリエンジンは単一のインデックスのみを考慮します。つまり、既存のインデックスは、カスタムインデックスプロパティをさらに追加することでカスタマイズでき、またそうする必要があります。

このドキュメントの [JCR クエリのチートシート](#jcr-query-cheatsheet)セクションでは、使用可能な制約を一覧表示し、インデックス定義が検出されるためにどのように見える必要があるかを説明します。[クエリパフォーマンスツール](#query-performance-tool)を使用してクエリをテストし、適切なインデックスが使用され、クエリエンジンがインデックス外の制約を評価する必要がないことを確認します。

### 順序 {#ordering}

結果が特定の順序で要求される場合、クエリエンジンでこれを実現するには、次の 2 つの方法があります。

1. インデックスは、結果を完全に正しい順序で提供できます。
   * これが機能するのは、順序付けに使用されるプロパティがインデックス定義において `ordered=true` で注釈付けされている場合です。
1. クエリエンジンが順序付けプロセスを実行します。
   * これは、クエリエンジンがインデックスの外部でフィルタリングを実行したり、または順序プロパティが `ordered=true` プロパティで注釈付けされてない場合に発生する可能性があります。
   * この場合、結果セット全体が並べ替えのためにメモリに読み込まれる必要があり、最初のオプションよりはるかに時間がかかります。

### 結果のサイズを制限 {#restrict-result-size}

クエリ結果の取得サイズは、クエリパフォーマンスの重要な要因です。結果は遅延的に取得されるので、最初の 20 件の結果の取得と 10,000 件の結果の取得を比較すると、ランタイムとメモリ使用量ともに違いが生じます。

つまり、結果セットのサイズは、すべての結果が取得された場合にのみ正しく判断できます。このため、取得する結果セットは、クエリを拡張するか（詳しくはこのドキュメントの [JCR クエリのチートシート](#jcr-query-cheatsheet)の節を参照）、または結果の読み取りを制限することで、常に制限する必要があります。

このような制限は、クエリエンジンが 100,000 のノードの&#x200B;**トラバーサルの制限**&#x200B;に達することを防ぎ、クエリを強制的に停止します。

大きな結果セットを完全に処理する必要がある場合は、このドキュメントの[結果の大きいクエリ](#queries-with-large-result-sets)セクションを参照してください。

## JCR クエリのチートシート {#jcr-query-cheatsheet}

効率的な JCR クエリとインデックス定義を作成できるようにするため、開発時に [JCR クエリチートシート](https://experienceleague.adobe.com/docs/experience-manager-65/deploying/practices/best-practices-for-queries-and-indexing.html?lang=ja#jcrquerycheatsheet)をダウンロードして参照用として使用できます。

これには QueryBuilder、XPath、SQL-2 のクエリの例が収録されていて、クエリのパフォーマンスの点で異なる動作をする複数のシナリオに対応できます。また、Oak インデックスの作成またはカスタマイズ方法に関する推奨事項も収録されています。このチートシートの内容は、AEM as a Cloud Service および AEM 6.5 に適用されます。

## 大きな結果セットを持つクエリ {#queries-with-large-result-sets}

結果セットが大きくなるようなクエリを避けることが推奨されますが、大きな結果セットを処理する必要がある場合もあります。結果のサイズは事前にわからないことが多いので、処理の信頼性を高めるためには注意が必要です。

* クエリは、リクエスト内で実行しないでください。代わりに、Sling ジョブまたは AEM ワークフローの一部としてクエリを実行する必要があります。これらは、合計ランタイムに制限がなく、クエリやその結果の処理中にインスタンスが停止しても再起動されます。
* 100,000 個のノードに対するクエリ制限を克服するには、[キーセットのページネーション](https://jackrabbit.apache.org/oak/docs/query/query-engine.html#Keyset_Pagination)の使用を検討し、クエリを複数のサブクエリに分割する必要があります。

## リポジトリトラバーサル {#repository-traversal}

リポジトリをトラバースするクエリではインデックスが使用されず、次のようなメッセージでログに記録されます。

```text
28.06.2022 13:32:52.804 *WARN* [127.0.0.1 [1656415972414] POST /libs/settings/granite/operations/diagnosis/granite_queryperformance.explain.json HTTP/1.1] org.apache.jackrabbit.oak.plugins.index.Cursors$TraversingCursor Traversed 98000 nodes with filter Filter(query=select [jcr:path], [jcr:score], * from [nt:base] as a /* xpath: //* */, path=*) called by com.adobe.granite.queries.impl.explain.query.ExplainQueryServlet.getHeuristics; consider creating an index or changing the query
```

このログスニペットを使用すると、次の項目を確認できます。

* クエリ自体： `//*`
* このクエリを実行した Java コード： `com.adobe.granite.queries.impl.explain.query.ExplainQueryServlet::getHeuristics` はクエリの作成者を特定するのに役立ちます。

この情報を使用すると、このドキュメントの[クエリの最適化](#optimizing-queries)の節で説明している方法を使用して、このクエリを最適化できます。
