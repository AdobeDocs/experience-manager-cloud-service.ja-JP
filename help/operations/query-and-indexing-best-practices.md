---
title: クエリとインデックス作成のベストプラクティス
description: Adobeのベストプラクティスガイドラインに基づいてインデックスとクエリを最適化する方法を説明します。
topic-tags: best-practices
exl-id: 37eae99d-542d-4580-b93f-f454008880b1
source-git-commit: afeff7cfb8606eb58126a4ca62ce9e6e58c44215
workflow-type: tm+mt
source-wordcount: '1563'
ht-degree: 28%

---

# クエリとインデックス作成のベストプラクティス {#query-and-indexing-best-practices}

AEM as a Cloud Serviceでは、インデックス作成に関する操作上の側面はすべて自動化されます。 これにより、開発者は、効率的なクエリと、それに対応するインデックス定義の作成に専念できます。

## クエリを使用する必要がある場合 {#when-to-use-queries}

クエリはコンテンツにアクセスする方法ですが、可能性があるのはそれだけではありません。 多くの場合、リポジトリ内のコンテンツに他の方法でより効果的にアクセスできます。 クエリが、使用事例に応じてコンテンツにアクセスする最適で最も効率的な方法かどうかを検討する必要があります。

### リポジトリと分類の設計 {#repository-and-taxonomy-design}

リポジトリの分類を設計する際は、いくつかの要素を考慮する必要があります。これには、アクセス制御、ローカライゼーション、コンポーネントおよびページプロパティの継承などが含まれます。

こうした事柄に対応する分類を設計する一方で、インデックス設計の「トラバーサビリティ」についても検討することも重要です。このコンテキストでのトラバーサビリティとは、分類を使用して、パスに基づいてコンテンツに予測可能にアクセスできる機能です。 これにより、複数のクエリを実行する必要があるシステムよりも、管理が容易な、より効率的なシステムが実現します。

さらに分類を設計する際は、順序が重要かどうか検討することが重要です。明確な順序が不要な場合および多数の兄弟ノードが予想される場合は、`sling:Folder` や `oak:Unstructured` などの順序がないノードタイプを使用することを推奨します。順序付けが必要な場合は、`nt:unstructured` および `sling:OrderedFolder` の方が適切です。

### コンポーネント内のクエリ {#queries-in-components}

クエリは、AEM システムで実行される際の負荷が比較的大きい処理なので、コンポーネント内のクエリはできる限り避けるようにします。ページがレンダリングされるたびに複数のクエリを実行すると、システムのパフォーマンス低下につながります。コンポーネントのレンダリング時にクエリを実行しないようにするには、次の 2 つの方法があります。 **[ノードの走査](#traversing-nodes)** および **[結果をプリフェッチします。](#prefetching-results)**

### ノードの走査 {#traversing-nodes}

必要なデータの場所を事前に把握できるように設計されたリポジトリの場合は、データを発見するためのクエリを実行する必要はなく、そのデータを必要なパスから取得するコードをデプロイできます。

例として考えられるのは、特定のカテゴリに適合するコンテンツをレンダリングする場合です。これを実現する 1 つの方法は、コンテンツをカテゴリプロパティで整理し、このプロパティをクエリして、カテゴリ内のアイテムを表示するコンポーネントに割り当てることです。

もっと良い方法は、コンテンツをカテゴリ別の分類で構造化し、コンテンツを手動で取得できるようにすることです。

例えば、コンテンツが以下の場所に似た分類で格納されている場合は、

```xml
/content/myUnstructuredContent/parentCategory/childCategory/contentPiece
```

`/content/myUnstructuredContent/parentCategory/childCategory` ノードは簡単に取得でき、その子ノードを解析してコンポーネントのレンダリングに使用できます。

さらに、小規模または一様なデータセットを扱う場合は、同じ結果セットを返すためにクエリを作成するよりも、リポジトリを走査して必要なノードを収集するほうが速い場合があります。一般論として、クエリはできる限り使用せずに済ませることを推奨します。

### 結果の先取り {#prefetching-results}

コンポーネントのコンテンツや要件によっては、必要なデータを取得する方法としてノードトラバーサルを使用できない場合があります。 このような場合、最適なパフォーマンスを確保するために、コンポーネントがレンダリングされる前に、必要なクエリを実行する必要があります。

コンポーネントに必要な結果が、作成時に計算でき、コンテンツが変更される予測がない場合は、変更後にクエリを実行できます。

データまたはコンポーネントが定期的に変更される場合は、スケジュールに従って、または基礎データの更新リスナーを使用してクエリを実行できます。クエリの結果は、リポジトリ内の共有の場所に書き込むことができます。このデータを必要とするコンポーネントは、実行時にクエリを実行しなくても、この 1 つのノードから値を取り出すことが可能です。

同様の方法を使用して、結果をメモリ内キャッシュに保持できます。メモリ内キャッシュは、起動時に入力され、変更がおこなわれるたびに（JCR を使用して）更新されます `ObservationListener` または Sling `ResourceChangeListener`) をクリックします。

## クエリの最適化 {#optimizing-queries}

Oak ドキュメントでは、 [クエリの実行方法の概要です。](https://jackrabbit.apache.org/oak/docs/query/query-engine.html#query-processing) これは、このドキュメントで説明するすべての最適化アクティビティの基礎となります。

AEM as a Cloud Serviceには、効率的なクエリの実装をサポートするクエリパフォーマンスツールが用意されています。

* 実行済みのクエリと、関連するパフォーマンス特性およびクエリプランが表示されます。
* クエリプランの表示から完全なクエリの実行まで、様々なレベルでアドホッククエリを実行できます。

クエリパフォーマンスツールには、 [Cloud Manager の開発者コンソール。](https://experienceleague.adobe.com/docs/experience-manager-learn/cloud-service/debugging/debugging-aem-as-a-cloud-service/developer-console.html?lang=ja#queries) AEM as a Cloud Serviceのクエリパフォーマンスツールでは、AEM 6.x バージョンに対するクエリの実行の詳細に関する詳細が提供されます。

このグラフは、クエリパフォーマンスツールを使用してクエリを最適化するための一般的なフローを示しています。

![クエリ最適化フロー](assets/query-optimization-flow.png)

### インデックスの使用 {#use-an-index}

最適なパフォーマンスを実現するには、すべてのクエリでインデックスを使用する必要があります。 ほとんどの場合、既存の標準提供インデックスでクエリを処理するだけで十分です。

既存のインデックスにカスタムプロパティを追加する必要がある場合は、インデックスを使用して追加の制約を照会できます。 ドキュメントを参照 [コンテンツの検索とインデックス作成](/help/operations/indexing.md#changing-an-index) を参照してください。 この [JCR クエリのチートシート](#jcr-query-cheatsheet) このドキュメントの節では、特定のクエリタイプをサポートするために、インデックスのプロパティ定義を参照する必要がある方法について説明します。

### 適切な条件を使用 {#use-the-right-criteria}

クエリの主な制約は、プロパティの一致である必要があります。これは最も効率的な型です。 プロパティ制約をさらに追加すると、結果がさらに絞り込まれます。

クエリエンジンは単一のインデックスのみを考慮します。 つまり、既存のインデックスにカスタムインデックスプロパティを追加することで、既存のインデックスをカスタマイズでき、カスタマイズする必要があります。

この [JCR クエリのチートシート](#jcr-query-cheatsheet) このドキュメントの節では、使用可能な制約を示し、インデックス定義を取得するためにどのように参照する必要があるかを説明します。 以下を使用： [クエリパフォーマンスツール](#query-performance-tool) を使用してクエリをテストし、適切なインデックスが使用され、クエリエンジンがインデックス外の制約を評価する必要がないことを確認します。

### 順序 {#ordering}

結果の特定の順序がリクエストされた場合、クエリエンジンでこれを実現するには、次の 2 つの方法があります。

1. インデックスを使用すると、結果を完全に正しい順序で配信できます。
   * これは、順序に使用されるプロパティに `ordered=true` を使用します。
1. クエリエンジンが順序付けプロセスを実行します。
   * これは、クエリエンジンがインデックスの外部でフィルタリングを実行した場合、または `ordered=true` プロパティ。
   * これを行うには、結果セット全体が並べ替えのためにメモリに読み込まれる必要があり、最初のオプションよりはるかに時間がかかります。

### 結果のサイズを制限 {#restrict-result-size}

クエリ結果の取得サイズは、クエリパフォーマンスの重要な要因です。 結果は遅延的に取得されるので、ランタイムとメモリの両方で、10,000 個の結果を取得する場合と比較して、最初の 20 個の結果を取得する場合に違いがあります。

つまり、結果セットのサイズは、すべての結果が取得された場合にのみ正しく判断できます。 このため、取得する結果セットは、クエリを拡張することで常に制限される必要があります ( [JCR クエリのチートシート](#jcr-query-cheatsheet) の節を参照 ) または結果の読み取りを制限することによって参照できます。

このような制限は、クエリエンジンが **横断限界** 100,000 個のノードで構成され、クエリが強制的に停止します。

の節を参照してください。 [結果の大きいクエリ](#queries-with-large-result-sets) を参照してください。

## JCR クエリのチートシート {#jcr-query-cheatsheet}

効率的な JCR クエリとインデックス定義を作成できるようにするため、開発時に [JCR クエリチートシート](https://experienceleague.adobe.com/docs/experience-manager-65/deploying/practices/best-practices-for-queries-and-indexing.html#jcrquerycheatsheet)をダウンロードして参照用として使用できます。

QueryBuilder、XPath、SQL-2 のクエリ例が含まれ、クエリのパフォーマンスの点で異なる動作をする複数のシナリオについて説明します。 また、Oak インデックスの作成またはカスタマイズ方法に関する推奨事項も収録されています。このチートシートの内容は、AEM 6.5 とas a Cloud Service 6.5 に適用されます。

## 大きな結果セットを持つクエリ {#queries-with-large-result-sets}

結果セットが大きい場合はクエリを避けることをお勧めしますが、大きな結果セットを処理する必要がある場合もあります。 結果のサイズは前もって知られていないので、処理を信頼できるものにするために、いくつかの注意を払う必要があります。

* クエリは、リクエスト内で実行しないでください。 代わりに、Sling ジョブまたはAEMワークフローの一部としてクエリを実行する必要があります。 これらのパラメーターは、合計ランタイムに制限がなく、クエリの処理中にインスタンスが停止し、その結果が出た場合に再起動されます。
* 100,000 個のノードに対するクエリ制限を克服するには、 [キーセットのページネーション](https://jackrabbit.apache.org/oak/docs/query/query-engine.html#Keyset_Pagination) クエリを複数のサブクエリに分割します。

## リポジトリトラバーサル {#repository-traversal}

リポジトリを走査するクエリではインデックスが使用されず、次のようなメッセージでログが記録されます。

```text
28.06.2022 13:32:52.804 *WARN* [127.0.0.1 [1656415972414] POST /libs/settings/granite/operations/diagnosis/granite_queryperformance.explain.json HTTP/1.1] org.apache.jackrabbit.oak.plugins.index.Cursors$TraversingCursor Traversed 98000 nodes with filter Filter(query=select [jcr:path], [jcr:score], * from [nt:base] as a /* xpath: //* */, path=*) called by com.adobe.granite.queries.impl.explain.query.ExplainQueryServlet.getHeuristics; consider creating an index or changing the query
```

このログスニペットを使用して、次の項目を確認できます。

* クエリ自体： `//*`
* このクエリを実行した Java コード： `com.adobe.granite.queries.impl.explain.query.ExplainQueryServlet::getHeuristics` クエリの作成者を特定するのに役立ちます。

この情報を使用すると、 [クエリの最適化](#optimizing-queries) 」の節を参照してください。
